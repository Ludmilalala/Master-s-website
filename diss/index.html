<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Реферат - Синяева Элеонора Витальевна</title>
    <link rel="stylesheet" href="../css/master_style.css">
    <link rel="stylesheet" href="../css/science.css">
    <link rel="stylesheet" href="../css/diss.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@1.39.0/tsparticles.min.js"></script>
</head>

<body>

    <div id="tsparticles" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></div>

    <!-- Верхний блок -->
    <div class="top-block">
        <div class="lang-box">
            <!-- <a href="index_eng.html" class="lang-link">EN</a> -->
        </div>
        <div class="university-links">
            <a href="http://donntu.ru" target="_blank">ДонНТУ</a>
            <a href="http://masters.donntu.ru" target="_blank" title="Перейти на портал магистров ДонНТУ">Портал
                магистров</a>
        </div>
    </div>

    <!-- Шапка -->
    <div class="container">
        <header class="header">
            <div class="header-container">
                <div class="photo-container">
                    <a href="../photo_big.jpg">
                        <img src="../photo.jpg" width="180" height="240"
                            alt="Магистр ДонНТУ Синяева Элеонора Витальевна" class="profile-photo">
                    </a>
                </div>
                <div class="header-text">

                    <h1>Синяева Элеонора Витальевна</h1>
                    <h3><a href="http://fisp.iknt.donntu.ru/" target="_blank">Факультет интеллектуальных систем и
                            программирования</a></h3>
                    <h3><a href="http://fisp.iknt.donntu.ru/kafedra-programmnoy-inzhenerii-imeni-lva-petrovicha-feldmana"
                            target="_blank">Кафедра программной инженерии</a></h3>
                    <h3>Направление: 09.04.04 «Программная инженерия им. Л.П. Фельдмана»</h3>
                    <h3>Профиль подготовки: «Методы и средства разработки программного обеспечения»</h3>
                    <h2>Тема выпускной квалификационной работы магистра: «Исследование использования нейронных сетей для
                        автоматического
                        определения и исправления ошибок
                        в программном коде»</h2>
                    <h3>Руководитель ВКР: к.э.н, доцент Боднар Алина Валериевна</h3>
                </div>
            </div>
        </header>
    </div>

    <!-- Основное содержимое -->
    <div class="container">
        <div class="content-wrapper">
            <nav class="main-menu">
                <div class="menu-container">
                    <a class="menu-button" href="../index.html">Резюме</a>
                    <a class="menu-button current" href="../diss/index.html">Реферат</a>
                    <a class="menu-button" href="../science/index.html">Научные труды</a>
                    <a class="menu-button" href="../ind/index.html">Индивидуальный раздел</a>
                </div>
            </nav>

            <main class="main-content dissertation-content">
                <div class="abstract-section">
                    <h2>Реферат по теме выпускной работы</h2>
                </div>

                <div class="content-section">
                    <h2>Содержание</h2>
                    <div class="toc-container">
                        <div class="toc-main">
                            <div class="toc-item">
                                <a href="#introduction" class="toc-link">Введение</a>
                            </div>

                            <div class="toc-item">
                                <div class="toc-chapter">
                                    <a href="#chapter1" class="toc-link">1 Анализ современных подходов к автоматическому
                                        обнаружению и исправлению ошибок в программном коде</a>
                                </div>
                                <div class="toc-subitems">
                                    <a href="#section1_1" class="toc-sublink">1.1 Понятие ошибок в программном коде и их
                                        классификация</a>
                                    <a href="#section1_2" class="toc-sublink">1.2 Обзор существующих подходов к поиску и
                                        исправлению ошибок</a>
                                    <a href="#section1_3" class="toc-sublink">1.3 Роль и возможности нейросетевых
                                        моделей в
                                        задачах поиска и исправления ошибок</a>
                                    <a href="#section1_4" class="toc-sublink">1.4 Преимущества и ограничения
                                        нейросетевых
                                        подходов</a>
                                    <a href="#section1_5" class="toc-sublink">1.5 Вывод по главе</a>
                                </div>
                            </div>

                            <div class="toc-item">
                                <div class="toc-chapter">
                                    <a href="#chapter2" class="toc-link">2 Проектирование нейросетевой модели для
                                        обнаружения и исправления ошибок в программном коде</a>
                                </div>
                                <div class="toc-subitems">
                                    <a href="#section2_1" class="toc-sublink">2.1 Постановка задачи и выбор архитектуры
                                        модели</a>
                                    <a href="#section2_2" class="toc-sublink">2.2 Подготовка данных для обучения и
                                        тестирования</a>
                                    <a href="#section2_3" class="toc-sublink">2.3 Концепция функционирования модели</a>
                                    <a href="#section2_4" class="toc-sublink">2.4 Вывод по главе</a>
                                </div>
                            </div>

                            <div class="toc-item">
                                <a href="#conclusion" class="toc-link">Заключение</a>
                            </div>

                            <div class="toc-item">
                                <a href="#references" class="toc-link">Список использованной литературы</a>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="main-content-section">
                    <section id="introduction">
                        <h2>Введение</h2>

                        <p>Современные программные системы становятся всё более сложными, а стоимость ошибок в
                            программном коде — всё выше. Несмотря на развитие технологий тестирования и отладки,
                            значительное количество багов остаются невыявленными до стадии эксплуатации, что приводит к
                            существенным временным и финансовым затратам. В этой связи растёт интерес к интеллектуальным
                            методам автоматизации поиска и исправления ошибок, в частности — к применению нейросетевых
                            моделей, которые способны анализировать программный код, выявлять дефекты и предлагать
                            корректировки.</p>

                        <p>Разработка таких моделей особенно актуальна в условиях стремительного роста кода с открытым
                            исходным текстом и многообразия языков программирования <a href="#references" class="ref-link">[1]</a>. Интеграция нейронных сетей в
                            процессы разработки программного обеспечения может существенно повысить производительность
                            труда программистов и надёжность создаваемых продуктов <a href="#references"
                                class="ref-link">[2]</a>.</p>

                        <p>Целью исследования является разработка и исследование модели на основе нейронных сетей,
                            способной автоматически находить и исправлять ошибки в программном коде на популярных языках
                            программирования. В рамках поставленной задачи предполагается, что на вход модели подаётся
                            фрагмент исходного кода, содержащий потенциальную ошибку, а на выходе формируется
                            исправленная версия кода, соответствующая синтаксису и логике исходного языка <a
                                href="#references" class="ref-link">[3]</a>.</p>

                        <p>Основные задачи исследования включают анализ существующих методов автоматического обнаружения
                            и исправления ошибок в программном коде, изучение подходов к применению нейронных сетей в
                            области программного анализа, разработку архитектуры модели нейронной сети, адаптированной
                            для задачи исправления ошибок, реализацию прототипа модели и оценку её точности и
                            эффективности <a href="#references" class="ref-link">[4]</a>.</p>

                        <p>Объектом исследования выступают процессы автоматического анализа и исправления ошибок в
                            программном коде, а предметом исследования — методы и модели машинного обучения, в частности
                            нейронные сети, применяемые для поиска и устранения ошибок в исходном коде <a
                                href="#references" class="ref-link">[5]</a>.</p>

                        <p>Научная новизна работы заключается в разработке универсальной модели нейронной сети,
                            способной автоматически находить и исправлять ошибки в программном коде, написанном на
                            различных языках. В отличие от существующих решений, модель ориентирована не только на
                            синтаксические ошибки, но и на логические дефекты, что расширяет сферу её применения.</p>

                        <p>Практическая значимость исследования состоит в том, что разработанная модель может быть
                            интегрирована в системы автоматизированного тестирования и анализа программного кода,
                            значительно снижая трудозатраты на отладку, повышая надёжность программ и ускоряя их вывод
                            на рынок. Модель может быть использована в средах разработки (IDE) и платформах с открытым
                            исходным кодом для автоматической проверки и корректировки внесённых изменений.</p>
                    </section>

                    <section id="chapter1">
                        <h2>1 Анализ современных подходов к автоматическому обнаружению и исправлению ошибок в
                            программном коде</h2>

                        <h3 id="section1_1">1.1 Понятие ошибок в программном коде и их классификация</h3>
                        <p>Разработка программного обеспечения представляет собой сложный и многоэтапный процесс,
                            включающий проектирование, реализацию, тестирование и сопровождение. На каждом из этих
                            этапов могут возникать ошибки, приводящие к отклонению поведения программы от ожидаемого.
                            Такие отклонения принято называть ошибками или багами.</p>

                        <p>Ошибки в коде являются одной из главных причин сбоев, уязвимостей и нестабильности
                            программных систем. Согласно статистике, устранение ошибок после развертывания системы
                            обходится в десятки раз дороже, чем их устранение на ранних стадиях разработки. Более того,
                            в критичных областях (авионика, медицина, финансовые системы) наличие даже одной ошибки
                            может привести к катастрофическим последствиям.</p>

                        <p>Под ошибкой в программировании понимается любое действие разработчика, результат которого
                            приводит к тому, что программа не выполняет требуемую функцию, выполняет её ненадлежащим
                            образом, выполняет ненадлежащие действия, не предусмотренные спецификацией, или прекращает
                            выполнение <a href="#references" class="ref-link">[10]</a>. Ошибки могут быть как очевидными, так и скрытыми, проявляющимися только при
                            определённой комбинации входных данных.</p>

                        <p>В рамках исследования принята классификация ошибок на синтаксические, семантические,
                            логические и ошибки времени выполнения. Синтаксические ошибки связаны с нарушением правил
                            грамматики языка программирования и обычно выявляются на этапе компиляции. Семантические
                            ошибки возникают, когда синтаксис программы корректен, но логика её выполнения не
                            соответствует ожидаемому поведению. Логические ошибки являются наиболее опасной категорией
                            багов, поскольку программа может выполняться без сбоев, но результат её работы будет
                            неправильным. Ошибки времени выполнения проявляются только в процессе выполнения программы.
                        </p>

                        <h3 id="section1_2">1.2 Обзор существующих подходов к поиску и исправлению ошибок</h3>
                        <p>Для автоматизации поиска и устранения ошибок в программном коде разработано множество
                            инструментов и методов, которые можно условно разделить на четыре основные категории:
                            статический анализ, динамический анализ, символьное исполнение и тестирование с генерацией
                            входных данных (fuzzing) <a href="#references" class="ref-link">[12]</a>.</p>

                        <p>Статический анализ представляет собой метод анализа исходного кода без его выполнения. Он
                            проводится на уровне исходного текста программы или промежуточного представления и позволяет
                            выявить широкий спектр ошибок на раннем этапе разработки. К числу наиболее распространённых
                            статических анализаторов относятся SonarQube, FindBugs, Pylint и ESLint. Статический анализ
                            эффективен при обнаружении синтаксических и семантических ошибок, нарушений соглашений о
                            стиле, дублирования кода и потенциальных уязвимостей.</p>

                        <p>Динамический анализ проводится в процессе выполнения программы. Он позволяет наблюдать
                            поведение приложения при различных входных данных, отслеживать ресурсы, выявлять ошибки
                            времени выполнения и проблемы, связанные с использованием памяти. Типичные инструменты
                            динамического анализа включают Valgrind, Purify и AddressSanitizer. Динамический анализ
                            особенно полезен для обнаружения багов, связанных с памятью, параллельным выполнением,
                            утечками ресурсов.</p>

                        <p>Символьное исполнение представляет собой метод анализа кода, при котором вместо конкретных
                            значений переменных используется символическое представление. Программа анализируется как
                            множество логических выражений, описывающих возможные пути её выполнения при различных
                            входных данных. Одним из наиболее известных инструментов, реализующих этот подход, является
                            KLEE. Символьное исполнение позволяет выявлять ошибки, которые возникают только при
                            определённых комбинациях входных данных или условиях ветвлений.</p>

                        <p>Fuzzing — это техника автоматического тестирования, при которой программа многократно
                            запускается с различными, часто случайно или полурандомно сгенерированными входными данными,
                            с целью выявления сбоев, зависаний или нарушений безопасности. Примеры инструментов включают
                            AFL, libFuzzer и Honggfuzz. Преимущество fuzzing-подхода заключается в его простоте и
                            эффективности при поиске неочевидных уязвимостей.</p>

                        <p>Все описанные методы активно используются в промышленности и научных исследованиях, однако у
                            них есть одно общее ограничение — они в основном ориентированы на диагностику ошибок, но не
                            на их исправление. При выявлении дефекта требуется вмешательство человека, который
                            анализирует отчёт и вручную вносит изменения в код.</p>

                        <h3 id="section1_3">1.3 Роль и возможности нейросетевых моделей в задачах поиска и исправления
                            ошибок
                        </h3>
                        <p>С развитием методов машинного обучения и особенно глубоких нейросетевых архитектур появилась
                            возможность рассматривать программный код не просто как формальный текст, а как сложную
                            структуру, поддающуюся семантическому анализу <a href="#references" class="ref-link">[18]</a>. Современные модели способны не только
                            анализировать код на предмет ошибок, но и предлагать исправления, подражая логике действий
                            опытного программиста.</p>

                        <p>Одним из ключевых преимуществ применения нейросетей к анализу кода является способность
                            учитывать контекст. Традиционные методы анализа ориентированы на жёсткие правила и шаблоны,
                            в то время как нейронные сети способны выявлять закономерности в структурах кода, обучаясь
                            на больших выборках. Такой подход особенно эффективен для обнаружения логических и
                            семантических ошибок, которые слабо поддаются формализации.</p>

                        <p>Для обработки программного кода применяются архитектуры, изначально разработанные для
                            обработки естественного языка. К наиболее распространённым относятся рекуррентные нейронные
                            сети (RNN), двунаправленные модели (BiRNN) и особенно трансформерные архитектуры, такие как
                            BERT, GPT, T5 и их адаптации к исходному коду: CodeBERT, CodeT5, GraphCodeBERT, PolyCoder,
                            AlphaCode и другие.</p>

                        <p>Примером раннего успешного применения нейросетей стала модель DeepFix, предложенная
                            исследователями из Индийского технологического института в 2016 году. Она использовала
                            рекуррентную нейронную сеть для исправления синтаксических ошибок в коде на языке C. Модель
                            принимала некорректный фрагмент программы на вход и генерировала исправленную версию,
                            минимизируя расстояние Левенштейна до эталонного кода.</p>

                        <p>Дальнейшие исследования сфокусировались на более сложных задачах, таких как обнаружение багов
                            и предложение патчей для исправления. Так, модель CoCoNut использует контекстное
                            представление кода и специализированные слои внимания, что позволяет ей эффективно находить
                            и исправлять ошибки в коде на Java. Модель CodeBERT, разработанная Microsoft Research,
                            представляет собой адаптацию архитектуры BERT для двуязычных пар: программный код и
                            естественный язык.</p>

                        <p>Особую категорию представляют графовые модели, такие как GraphCodeBERT, в которых
                            дополнительно учитываются структурные связи между элементами кода — например, узлы и рёбра в
                            дереве разбора (AST). Это позволяет модели лучше понимать структуру программы, что критично
                            для выявления сложных логических ошибок.</p>

                        <p>Нейросетевые подходы находят применение не только в академических исследованиях, но и в
                            промышленности. Так, в редакторах Visual Studio Code, PyCharm, IntelliJ IDEA уже
                            интегрированы механизмы интеллектуального автодополнения и исправления ошибок, частично
                            основанные на машинном обучении. Примером может служить GitHub Copilot, работающий на базе
                            модели OpenAI Codex, который способен предсказывать целые фрагменты кода и выявлять
                            потенциальные дефекты ещё до компиляции.</p>

                        <h3 id="section1_4">1.4 Преимущества и ограничения нейросетевых подходов</h3>
                        <p>Применение нейросетевых моделей для анализа и исправления ошибок в программном коде
                            предоставляет широкие возможности, ранее недоступные при использовании традиционных методов.
                            Одним из главных преимуществ нейросетевых моделей, особенно архитектур на основе
                            трансформеров, является их способность анализировать код не построчно, а в широком
                            контексте. Это означает, что модель может учитывать информацию о переменных, функциях и
                            структурах, определённых в других частях программы, и на этой основе делать более точные
                            выводы.</p>

                        <p>Другим важным преимуществом является универсальность и масштабируемость нейросетевых моделей.
                            Они могут быть обучены на коде, написанном на разных языках программирования. Современные
                            модели, такие как CodeT5 или PolyCoder, показывают хорошие результаты на Java, Python, C++,
                            JavaScript и других языках. Более того, обучение на мульти-языковых корпусах делает
                            возможным перенос моделей с одного языка на другой, что расширяет спектр их применения.</p>

                        <p>В отличие от большинства статических и динамических анализаторов, которые только указывают на
                            наличие ошибки, нейросети способны генерировать конкретные предложения по исправлению. Это
                            может быть как точечное исправление, так и переписывание целого фрагмента кода, включая
                            изменение структуры условий, циклов и вызовов функций.</p>

                        <p>Однако нейросетевые подходы не лишены ограничений. Основная проблема — необходимость в
                            больших и качественно размеченных корпусах данных. Многие открытые наборы данных, такие как
                            Defects4J, Bugs2Fix, ManySStuBs4J, содержат ограниченное количество примеров и не всегда
                            охватывают широкий спектр языков и типов ошибок. Кроме того, обучение крупных трансформеров
                            требует значительных вычислительных ресурсов, что ограничивает доступность таких моделей
                            <a href="#references" class="ref-link">[28]</a>.
                        </p>

                        <p>Также вызывает озабоченность вопрос интерпретируемости — большинство нейросетевых моделей
                            функционируют как «чёрный ящик», и сложно объяснить, почему была предложена та или иная
                            модификация кода. Это особенно критично в системах с повышенными требованиями к безопасности
                            и надёжности. Иногда нейросеть генерирует код, который синтаксически корректен, но логически
                            неверен, что может ввести в заблуждение менее опытных разработчиков.</p>

                        <h3 id="section1_5">1.5 Вывод по главе</h3>
                        <p>В первой главе был проведён всесторонний анализ современного состояния в области
                            автоматического обнаружения и исправления ошибок в программном коде. Были рассмотрены
                            основные типы ошибок, включая синтаксические, семантические, логические и ошибки времени
                            выполнения. Понимание их природы и классификации является необходимым условием для
                            построения эффективных автоматизированных систем анализа и коррекции кода.</p>

                        <p>На основании обзора традиционных методов было показано, что статический и динамический
                            анализ, символьное исполнение, а также методы fuzzing позволяют эффективно выявлять широкий
                            спектр дефектов. Однако основным их ограничением является неспособность к автоматической
                            генерации исправлений и низкая эффективность при обработке логических и сложных
                            семантических ошибок.</p>

                        <p>В то же время нейросетевые подходы, основанные на моделях глубокого обучения,
                            продемонстрировали высокую перспективность в решении задач автоматической коррекции кода.
                            Они обладают способностью учитывать широкий контекст, работать с несколькими языками
                            программирования, предлагать исправления и масштабироваться под различные задачи. Особенно
                            эффективными являются модели на базе трансформерных архитектур — таких как CodeBERT, CodeT5,
                            GraphCodeBERT, которые уже показали свою применимость в реальных системах.</p>
                    </section>

                    <section id="chapter2">
                        <h2>2 Проектирование нейросетевой модели для обнаружения и исправления ошибок в программном коде
                        </h2>

                        <h3 id="section2_1">2.1 Постановка задачи и выбор архитектуры модели</h3>
                        <p>Разработка программного обеспечения сопряжена с высокой вероятностью появления ошибок,
                            возникающих как на этапе проектирования, так и в процессе реализации. Эти ошибки могут быть
                            синтаксическими, логическими, семантическими или касаться выполнения программы во времени.
                            Несмотря на наличие современных систем статического и динамического анализа, значительное
                            количество багов остаётся незамеченным до поздних этапов разработки или внедрения
                            программного продукта.</p>

                        <p>Целью данной работы является разработка и обучение модели, способной автоматически
                            обнаруживать и исправлять ошибки в программном коде на популярных языках программирования. В
                            рамках поставленной задачи предполагается, что на вход модели подаётся фрагмент исходного
                            кода, содержащий потенциальную ошибку, а на выходе формируется исправленная версия кода,
                            соответствующая синтаксису и логике исходного языка. Модель должна уметь учитывать контекст
                            кода и предлагать наиболее вероятное исправление.</p>

                        <p>Сформулированная задача относится к классу sequence-to-sequence (seq2seq) проблем, где вход и
                            выход представляют собой последовательности переменных длин. Подобные задачи характерны для
                            машинного перевода, генерации текста, автодополнения и, в рассматриваемом случае,
                            трансформации кода.</p>

                        <p>На основании анализа современных научных работ было установлено, что наилучшие результаты в
                            задачах автоматического исправления кода демонстрируют трансформерные архитектуры. Они
                            позволяют эффективно обрабатывать длинные последовательности, учитывать дальние зависимостей
                            между токенами и легко масштабируются под задачи многозадачного и многокодовного обучения.
                        </p>

                        <p>В качестве базовой архитектуры для решения поставленной задачи была выбрана модель CodeT5 —
                            модификация модели T5 (Text-to-Text Transfer Transformer), адаптированная для работы с
                            программным кодом. CodeT5 разработана командой Salesforce Research и обучена на большом
                            количестве исходного кода из GitHub с применением специальных предобучающих задач:
                            маскирование кода, восстановление документации, автодополнение, исправление кода и другие.
                        </p>

                        <p>Основные преимущества CodeT5 включают поддержку популярных языков программирования (Python,
                            Java, JavaScript, C++, Ruby и др.), encoder-decoder архитектуру, идеально подходящую для
                            seq2seq задач, возможность дообучения на пользовательских корпусах и наличие реализации в
                            библиотеке HuggingFace Transformers. Также рассматривались альтернативные варианты:
                            CodeBERT, GraphCodeBERT и PLBART, однако именно CodeT5 продемонстрировала лучшую
                            переносимость между задачами и возможность дообучения без полной переинициализации модели.
                        </p>

                        <h3 id="section2_2">2.2 Подготовка данных для обучения и тестирования</h3>
                        <p>Качество работы любой нейросетевой модели напрямую зависит от полноты, достоверности и
                            репрезентативности обучающего корпуса. Для задач автоматического исправления кода необходимо
                            сформировать обучающую выборку, содержащую пары «ошибочный код — исправленный код». Такие
                            данные должны охватывать различные типы ошибок: синтаксические, семантические, логические и
                            ошибки форматирования, встречающиеся в реальных программных проектах.</p>

                        <p>В рамках данной работы для обучения и тестирования модели были использованы следующие
                            общедоступные корпуса: Bugs2Fix — корпус, содержащий реальные баги из проектов на языке
                            Java, собранные с помощью анализа истории коммитов; ManySStuBs4J — включает типовые короткие
                            исправления, извлечённые из коммитов на GitHub; QuixBugs — набор компактных программ с
                            типичными алгоритмическими ошибками; Pythia или CodeXGLUE — дополнительно использовались для
                            дообучения на Python-коде.</p>

                        <p>Данные предварительно были приведены к единому формату, подходящему для обучения модели
                            CodeT5. Каждая пара представлена в виде двух строк: input (фрагмент ошибочного кода) и
                            target (соответствующее исправление). Важно, чтобы фрагменты были синтаксически валидны или
                            частично валидны, но не пусты. Кроме того, были удалены комментарии, временные переменные и
                            артефакты, не влияющие на анализ кода.</p>

                        <p>Перед подачей на вход модели все фрагменты были подвергнуты ряду предобработок: удаление
                            лишних пробелов, отступов, символов табуляции; унификация стиля; замена переменных и имён
                            функций на обобщённые; удаление повторяющихся и почти идентичных пар. Для синтаксической
                            проверки и валидации применялись встроенные инструменты языков программирования: компиляторы
                            и парсеры AST.</p>

                        <p>После очистки данные были токенизированы с помощью встроенного токенизатора SentencePiece,
                            входящего в состав CodeT5. Токенизация основана на модели BPE (byte-pair encoding),
                            позволяющей эффективно разбивать код на подсловные единицы, сохраняя синтаксические
                            конструкции и ключевые слова. Обучающая выборка была разбина на три части: обучающая выборка
                            (80%), валидационная (10%), тестовая (10%).
                        </p>

                        <p>Особое внимание уделялось равномерному распределению типов ошибок. Если в выборке преобладают
                            только синтаксические баги, модель склонна запоминать шаблоны и хуже справляется с
                            логическими отклонениями. Поэтому вручную или полуавтоматически были выделены подгруппы по
                            категориям: ошибки пропущенных символов, замены операторов, лишние или неверные конструкции,
                            ошибки в логике условий или циклов.</p>

                        <h3 id="section2_3">2.3 Концепция функционирования модели</h3>
                        <p>Представленная в данной работе модель исправления ошибок в программном коде основана на
                            принципах encoder-decoder архитектуры и реализует процесс трансформации входного
                            (ошибочного) кода в корректный с точки зрения синтаксиса и логики фрагмент<a href="#references" class="ref-link">[30]</a>. В рамках
                            функционирования системы можно выделить следующие ключевые стадии: получение входных данных,
                            предобработка и токенизация, формирование скрытого представления, генерация исправленного
                            кода, декодирование и постобработка.</p>

                        <p>На стадии получения входных данных пользователь или внешний инструмент предоставляет на вход
                            системы фрагмент кода, в котором потенциально содержатся ошибки. Это может быть как
                            завершённая функция, так и неполный конструктив. Затем входной код проходит предварительную
                            очистку и нормализацию, выполняется токенизация с помощью алгоритма SentencePiece,
                            адаптированного под работу с кодом.</p>

                        <p>На этапе формирования скрытого представления полученные токены преобразуются в эмбеддинги и
                            поступают в энкодер трансформера. Здесь формируется контекстное представление каждого
                            элемента кода на основе всего окружения, что позволяет учитывать зависимости между
                            переменными, структурами управления и логикой вызова функций. Скрытое представление
                            передаётся в декодер, который пошагово генерирует исправленную последовательность токенов с
                            использованием механизма перекрёстного внимания.</p>

                        <p>На заключительном этапе сгенерированная последовательность токенов преобразуется в текстовый
                            код, форматируется и при необходимости проходит синтаксическую проверку. На выходе
                            пользователь получает исправленный фрагмент, который может быть встроен обратно в проект.
                        </p>

                        <p>Проектируемая система может функционировать как в автономном режиме, так и в составе других
                            инструментов: IDE-плагин для визуального отображения ошибок и предложений по исправлению в
                            редакторе кода; CI/CD пайплайн для автоматической проверки кода перед коммитом; система
                            онлайн-проверки заданий для автопроверки студенческого кода; API-интерфейс для
                            взаимодействия с внешними сервисами через REST-запросы.</p>

                        <p>В отличие от классических систем, где фокус сделан на синтаксике, нейросетевой подход
                            позволяет работать с более широким спектром багов, включая пропущенные или избыточные
                            символы, логические ошибки, нарушения стиля, влияющие на читаемость, неправильные вызовы
                            методов и передача аргументов. Поскольку модель обучается на реальных парах «ошибка —
                            исправление», она способна предлагать осмысленные корректировки, подражая действиям опытного
                            разработчика.</p>

                        <h3 id="section2_4">2.4 Вывод по главе</h3>
                        <p>Во второй главе была спроектирована нейросетевая модель, предназначенная для автоматического
                            обнаружения и исправления ошибок в программном коде. На основе анализа современных
                            исследований и сравнения существующих решений была обоснована актуальность применения
                            трансформерных архитектур, в частности модели CodeT5. Эта модель адаптирована для работы с
                            исходным кодом и позволяет решать задачу исправления кода как задачу преобразования
                            последовательности (sequence-to-sequence), что делает её особенно подходящей для целей
                            данного исследования.</p>

                        <p>Была сформулирована задача и определён формат входных и выходных данных. В качестве основы
                            для обучения предложено использовать пары «ошибочный код — исправленный код», собранные из
                            открытых датасетов, таких как Bugs2Fix, ManySStuBs4J и QuixBugs. Также была рассмотрена
                            структура и характеристики этих наборов данных, предложены подходы к очистке, нормализации,
                            токенизации и балансировке выборки по типам ошибок. Это обеспечивает равномерное
                            представление различных видов багов и повышает устойчивость модели к разнообразным стилям
                            программирования <a href="#references" class="ref-link">[31]</a>.</p>

                        <p>Сформулированная концепция функционирования модели описывает полный пайплайн её работы: от
                            подачи исходного кода и его предобработки, до генерации исправлений, обратной токенизации и
                            вывода результата пользователю. Каждая стадия подробно описана и логически обоснована.
                            Принцип работы построен на последовательной трансформации входного кода с использованием
                            encoder-decoder архитектуры с attention-механизмами, обеспечивающими качественное
                            контекстуальное понимание и точность исправлений.</p>

                        <p>Проектируемая система обладает гибкой структурой, что позволяет её интегрировать в различные
                            среды — от образовательных платформ до промышленных систем контроля качества кода. Благодаря
                            модульности её можно дообучать на пользовательских корпусах, адаптировать под новые языки
                            программирования и использовать в составе IDE, CI/CD или облачных сервисов. Также
                            предусмотрены метрики для последующей оценки качества предсказаний: точность, редакционное
                            расстояние, BLEU и другие.</p>
                    </section>

                    <section id="conclusion">
                        <h2>Заключение</h2>
                        <p>В ходе учебной практики была выполнена теоретическая проработка темы магистерской
                            диссертации, связанной с применением нейросетевых моделей для автоматического исправления
                            программного кода. Были изучены существующие архитектуры, такие как CodeT5, CodeBERT,
                            GraphCodeBERT, проанализированы их преимущества и ограничения.</p>

                        <p>В качестве основной была выбрана модель CodeT5, адаптированная под задачи
                            seq2seq-трансформации кода. Подготовлены обучающие данные на основе открытых датасетов
                            Bugs2Fix, ManySStuBs4J, QuixBugs. Разработана структура пайплайна функционирования модели,
                            включающая предобработку, токенизацию, генерацию исправлений и оценку результатов.</p>

                        <p>Полученные знания и структура модели позволят в дальнейшем приступить к её реализации и
                            дообучению, а также сформируют основу для последующих глав магистерской диссертации. Учебная
                            практика выполнена в полном объёме и заложила прочный фундамент для научного исследования.
                        </p>

                        <p>При написании данного реферата магистерская работа еще не завершена. Окончательное
                            завершение: декабрь 2025 года. Полный текст работы и материалы по теме могут быть получены у
                            автора или её руководителя после указанной даты.</p>
                    </section>

                    <section id="references">
                        <h2>Список использованной литературы</h2>
                        <ol class="references-list">
                            <li id="ref1">Фэн Ц., Го Д., Тан Д. и др. CodeBERT: предварительно обученная модель для
                                программирования и естественного языка // arXiv:2002.08155.</li>
                            <li id="ref2">Ахмад В., Чакраборти С., Рэй Б. и др. Унифицированное предварительное обучение
                                для
                                понимания и генерации программ // arXiv:2103.06333.</li>
                            <li id="ref3">Кан М., Сон К. CodeT5+: открытые модели LLM для понимания и генерации кода //
                                arXiv:2305.07922.</li>
                            <li id="ref4">Туфано М. и др. Эмпирическое исследование исправления ошибок с помощью
                                нейронного
                                машинного перевода // ACM TSE.</li>
                            <li id="ref5">Ефимов С., Мартынов И. Обзор моделей генерации кода с использованием
                                трансформеров //
                                Вестник информационных технологий. -- 2022. -- №4. -- С. 35--41.</li>
                            <li id="ref6">Святов С.А. Модели анализа исходного кода на основе трансформеров //
                                Программные
                                продукты и системы. -- 2022. -- №1. -- С. 23--30.</li>
                            <li id="ref7">Леклер А., МакМиллан К. Рекомендации по датасетам для суммаризации исходного
                                кода //
                                arXiv:2005.00451.</li>
                            <li id="ref8">Пименов И. С., Козлов А. Н. Применение моделей машинного обучения для поиска
                                багов в
                                программном обеспечении // Современные проблемы науки и образования. -- 2022. -- №6.
                            </li>
                            <li id="ref9">Chen Z. et al. A Comprehensive Survey on Code Intelligence via Pre-trained
                                Models // ACM
                                Computing Surveys. -- 2023.</li>
                            <li id="ref10">OpenAI. Codex Technical Report. -- 2021.</li>
                            <li id="ref11">Vaswani A. et al. Attention is all you need // Advances in neural information
                                processing
                                systems. -- 2017.</li>
                            <li id="ref12">Devlin J. et al. BERT: Pre-training of deep bidirectional transformers for
                                language
                                understanding // arXiv:1810.04805.</li>
                            <li id="ref13">Brown T.B. et al. Language models are few-shot learners // arXiv:2005.14165.
                            </li>
                            <li id="ref14">Raffel C. et al. Exploring the limits of transfer learning with a unified
                                text-to-text
                                transformer // arXiv:1910.10683.</li>
                            <li id="ref15">Wang Y. et al. CodeT5: Identifier-aware unified pre-trained encoder-decoder
                                models for
                                code understanding and generation // arXiv:2109.00859.</li>
                            <li id="ref16">Guo D. et al. GraphCodeBERT: Pre-training code representations with data flow
                                //
                                arXiv:2009.08366.</li>
                            <li id="ref17">Li Y. et al. CodeXGLUE: A benchmark dataset and open challenge for code
                                intelligence //
                                arXiv:2102.04664.</li>
                            <li id="ref18">Allamanis M. et al. A survey of machine learning for big code and naturalness
                                // ACM
                                Computing Surveys. -- 2018.</li>
                            <li id="ref19">Hindle A. et al. On the naturalness of software // Communications of the ACM.
                                -- 2016.
                            </li>
                            <li id="ref20">Ray B. et al. A large-scale study of programming languages and code quality
                                in GitHub //
                                Communications of the ACM. -- 2017.</li>
                            <li id="ref21">Le Goues C. et al. A systematic study of automated program repair: Fixing 55
                                out of 105
                                bugs for $8 each // ICSE. -- 2012.</li>
                            <li id="ref22">Monperrus M. Automatic software repair: A bibliography // ACM Computing
                                Surveys. --
                                2018.</li>
                            <li id="ref23">Gazzola L. et al. Automatic software repair: A survey // IEEE Transactions on
                                Software
                                Engineering. -- 2019.</li>
                            <li id="ref24">Chen Z. et al. SequenceR: Sequence-to-sequence learning for end-to-end
                                program repair //
                                IEEE Transactions on Software Engineering. -- 2021.</li>
                            <li id="ref25">Bhatia S. et al. Automated correction for syntax errors in programming
                                assignments using
                                recurrent neural networks // arXiv:1603.06129.</li>
                            <li id="ref26">Фэн Ц., Го Д., Тан Д. и др. CodeBERT: предварительно обученная модель для
                                программирования и естественного языка // arXiv:2002.08155.</li>
                            <li id="ref27">Ахмад В., Чакраборти С., Рэй Б. и др. Унифицированное предварительное
                                обучение для
                                понимания и генерации программ // arXiv:2103.06333.</li>
                            <li id="ref28">Кан М., Сон К. CodeT5+: открытые модели LLM для понимания и генерации кода //
                                arXiv:2305.07922.</li>
                            <li id="ref29">Туфано М. и др. Эмпирическое исследование исправления ошибок с помощью
                                нейронного
                                машинного перевода // ACM TSE.</li>
                            <li id="ref30">Ефимов С., Мартынов И. Обзор моделей генерации кода с использованием
                                трансформеров //
                                Вестник информационных технологий. -- 2022. -- №4. -- С. 35--41.</li>
                            <li id="ref31">Святов С.А. Модели анализа исходного кода на основе трансформеров //
                                Программные
                                продукты и системы. -- 2022. -- №1. -- С. 23--30.</li>
                            <li id="ref32">Леклер А., МакМиллан К. Рекомендации по датасетам для суммаризации исходного
                                кода //
                                arXiv:2005.00451.</li>
                            <li id="ref33">Пименов И. С., Козлов А. Н. Применение моделей машинного обучения для поиска
                                багов в
                                программном обеспечении // Современные проблемы науки и образования. -- 2022. -- №6.
                            </li>
                            
                        </ol>
                    </section>
                </div>
            </main>
        </div>

        <footer class="footer-menu">
            <a class="footer-item" href="../index.html">Резюме</a>
            <a class="footer-item current">Реферат</a>
            <a class="footer-item" href="../science/index.html">Научные труды</a>
            <a class="footer-item" href="../ind/index.html">Индивидуальный раздел</a>
        </footer>
    </div>
    <script src="../js/particles-config.js"></script>
    <script src="../js/main.js"></script>
    <script src="../js/script.js"></script>
</body>

</html>