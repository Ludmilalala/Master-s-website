<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepFix: Исправление распространенных ошибок в языке C с помощью глубокого обучения - Синяева Элеонора
        Витальевна</title>
    <link rel="stylesheet" href="../../css/master_style.css">
    <link rel="stylesheet" href="../../css/article.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@1.39.0/tsparticles.min.js"></script>
</head>

<body>

    <div id="tsparticles" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></div>

    <!-- Верхний блок -->
    <div class="top-block">
        <div class="lang-box">
            <!-- <a href="article_eng1.html" class="lang-link">EN</a> -->
        </div>
        <div class="university-links">
            <a href="http://donntu.ru" target="_blank">ДонНТУ</a>
            <a href="http://masters.donntu.ru" target="_blank" title="Перейти на портал магистров ДонНТУ">Портал
                магистров</a>
        </div>
    </div>

    <!-- Основное содержимое -->
    <div class="container">
        <div class="article-container">
            <div class="article-content">
                <div class="udk">УДК 004.8</div>

                <div class="article-header">
                    <div class="article-title">
                        DEEPFIX: ИСПРАВЛЕНИЕ РАСПРОСТРАНЕННЫХ ОШИБОК В ЯЗЫКЕ C С ПОМОЩЬЮ ГЛУБОКОГО ОБУЧЕНИЯ
                    </div>

                    <div class="authors">
                        Рахул Гупта<sup>1</sup>, Сохам Пал<sup>1</sup>, Адитья Канаде<sup>1</sup>, Шириш
                        Шеваде<sup>1</sup>
                    </div>

                    <div class="university">
                        Факультет компьютерных наук и автоматизации, Индийский институт науки, Бангалор, Индия
                    </div>

                    <div class="contact">
                        <sup>1</sup> {rahul.gupta, soham.pal, kanade, shirish}@cs.iisc.ernet.in
                    </div>

                    <div class="abstract">
                        <p><strong>Гупта Р., Пал С., Канаде А., Шеваде Ш. DeepFix: Исправление распространенных ошибок в
                                языке C с помощью глубокого обучения.</strong> Проблема автоматического исправления
                            программных ошибок является очень активной темой исследований в программной инженерии. Это
                            сложная проблема, поскольку исправление даже одной ошибки может потребовать анализа всей
                            программы. На практике множество ошибок возникает из-за неопытности программистов с языком
                            программирования или недостатка внимания к деталям. Мы называем эти ошибки распространенными
                            программными ошибками. Они аналогичны грамматическим ошибкам в естественных языках.
                            Компиляторы могут обнаруживать такие ошибки, но их сообщения об ошибках обычно неточны. В
                            этой работе мы представляем сквозное решение под названием DeepFix, которое может исправлять
                            несколько таких ошибок в программе без использования каких-либо внешних инструментов для их
                            локализации или исправления. В основе DeepFix лежит многослойная нейронная сеть
                            "последовательность-последовательность" с механизмом внимания, которая обучается
                            предсказывать ошибочные местоположения в программе вместе с требуемыми правильными
                            операторами. На наборе из 6971 ошибочных программ на C, написанных студентами для 93 задач
                            программирования, DeepFix смог полностью исправить 1881 (27%) программ и частично исправить
                            1338 (19%) программ.</p>
                        <p class="keywords"><strong>Ключевые слова:</strong> глубокое обучение, исправление программ,
                            нейронные сети, компиляция, обработка ошибок</p>
                    </div>

                    <div class="section">
                        <div class="section-title">Введение</div>
                        <p>Отладка программных ошибок является одним из самых трудоемких видов деятельности для
                            программистов. Поэтому проблема автоматического исправления программных ошибок, также
                            называемая <em>исправлением программ</em>, является очень активной темой исследований в
                            программной инженерии [13]. Большинство методов исправления программ сосредоточены на
                            логических ошибках в программах. Используя спецификацию программы (такую как набор тестов
                            или утверждение), они пытаются исправить программу. Поскольку их фокус направлен на
                            исправление логических ошибок в отдельных программах, они предполагают, что программа
                            успешно компилируется.</p>

                        <p>Это оставляет за пределами охвата существующих методов большой и частый класс ошибок. К ним
                            относятся ошибки из-за отсутствия разделителей области видимости (таких как закрывающая
                            фигурная скобка), добавления лишних символов, использования несовместимых операторов или
                            отсутствия объявлений переменных. Такие ошибки возникают из-за неопытности программистов или
                            недостатка внимания к деталям и вызывают ошибки компиляции или сборки. Не только начинающие
                            студенты, но и опытные разработчики также допускают такие ошибки, как показало исследование
                            ошибок сборки в Google [17]. Мы называем их <em>распространенными программными
                                ошибками</em>. Они распространены в том смысле, что, в отличие от логических ошибок, они
                            не специфичны для конкретной задачи программирования, а связаны с общим синтаксисом и
                            структурой языка программирования. Они аналогичны грамматическим ошибкам в естественных
                            языках.</p>

                        <p>Мы предлагаем исправлять распространенные программные ошибки с помощью глубокого обучения.
                            Из-за взаимозависимостей между различными частями программы исправление даже одной ошибки
                            может потребовать анализа всей программы. Это делает их автоматическое исправление сложной
                            задачей. Требования к точности для исправления программ также довольно высоки. Обычное
                            понятие точности на уровне токенов слишком расслаблено для этой настройки. Чтобы исправление
                            было правильным, инструмент исправления должен точно воспроизвести всю последовательность,
                            относящуюся к исправлению.</p>

                        <p>Мы представляем <em>сквозное решение</em> под названием DeepFix, которое не использует
                            никаких внешних инструментов для локализации или исправления ошибок. Мы используем
                            компилятор только для проверки исправлений, предлагаемых DeepFix. В основе DeepFix лежит
                            многослойная нейронная сеть "последовательность-последовательность" с механизмом внимания
                            [2], состоящая из кодирующей рекуррентной нейронной сети (RNN) для обработки входных данных
                            и декодирующей RNN с вниманием, которая генерирует выходные данные. Сеть обучается
                            предсказывать ошибочное местоположение в программе вместе с правильным оператором. DeepFix
                            вызывает ее итеративно для исправления нескольких ошибок в программе одну за другой.</p>

                        <div class="figure">
                            <img src="../../img/Статья 1 Перевод 1.png" alt="Пример работы DeepFix">
                            <div class="figure-caption">Рисунок 1 – Пример программы с ошибкой и ее исправление с
                                помощью DeepFix</div>
                        </div>

                        <p>На рисунке 1(a) показана входная программа на C с отсутствующей закрывающей фигурной скобкой
                            в строке 13. На рисунке 1(c) показана программа после применения исправления, предложенного
                            DeepFix. DeepFix правильно предсказывает, что в строке 13 есть ошибка, и генерирует
                            последовательность с вставленной закрывающей фигурной скобкой после "return 0;". Чтобы
                            понять, как наша сеть правильно предсказывает исправление, мы визуализируем веса внимания,
                            назначенные DeepFix каждому токену во входной программе на рисунке 1(b). Цвет фона токена
                            пропорционален среднему весу внимания, назначенному ему сетью при предсказании
                            последовательности токенов в исправлении. Мы наблюдаем, что сеть захватывает локальный
                            контекст ближе к ошибочной строке (обведенной рамкой) и глобальный контекст (обведенный
                            тенью), который также содержит объявление main в строке 4 с <em>несопоставленной открывающей
                                фигурной скобкой</em>. Также интересно отметить, что внимание сравнительно меньше для
                            строк 6-10, а также для строк 14-18. Строки 14-18 определяют другую функцию pow, которая не
                            имеет отношения к исправляемой ошибке.</p>

                        <p>Компиляторы могут обнаруживать распространенные программные ошибки, но они обычно не
                            указывают местоположения ошибок точно [20]. Например, если мы скомпилируем программу на
                            рисунке 1(a) с помощью компилятора GCC, мы получим следующее сообщение об ошибке:</p>

                        <div class="code-block">
                            <pre>p.c: In function 'main':
p.c:18:2: error: expected declaration or
    statement at end of input
    return res;</pre>
                        </div>
                        <div class="code-caption">Сообщение об ошибке компилятора GCC</div>

                        <p>Сообщение об ошибке является одновременно загадочным и вводящим в заблуждение. Оно не
                            локализует ошибку до строки 13. Вместо этого оно ошибочно указывает на строку 18 в тексте
                            программы.</p>

                        <p>Распространенные программные ошибки не специфичны для какой-либо конкретной задачи
                            программирования. Два недавних подхода [3, 19] обучают нейронные сети на правильных
                            студенческих решениях <em>конкретной</em> задачи программирования и пытаются изучить
                            специфичные для задачи шаблоны для исправления ошибочных решений для <em>той же</em> задачи.
                            В сравнении, DeepFix может использоваться для решений любой неизвестной задачи
                            программирования. В отличие от DeepFix, нейронные сети, используемые в вышеупомянутых
                            подходах, не могут самостоятельно локализовать ошибки. Bhatia2016 используют префиксы,
                            указанные компилятором, а Pu2016 выполняют переборный поиск для локализации ошибок.
                            Основываясь на сообщении компилятора выше, подход в [3] будет рассматривать префикс до
                            строки 18 на рисунке 1(a) как правильный и попытается предсказать суффикс. Однако ошибка
                            находится гораздо раньше, в строке 13, и поэтому не может быть исправлена этим методом.
                            Исправление нетривиальных ошибок требует рассуждений о долгосрочных зависимостях в тексте
                            программы. Pu2016 обучают языковую модель предсказывать промежуточную строку, учитывая
                            операторы на предыдущей и следующей строках, и таким образом захватывают только короткий
                            локальный контекст. DeepFix использует модель "последовательность-последовательность" с
                            механизмом внимания для захвата долгосрочных зависимостей.</p>

                        <p>Мы применяем DeepFix на программах на C, написанных студентами для 93 различных задач
                            программирования в вводном курсе программирования. Характер этих задач и, следовательно,
                            программ сильно различается. Тем не менее, наша сеть хорошо обобщается для программ из всех
                            этих задач. Из 6971 ошибочных программ DeepFix исправил 1881 (27%) программ
                            <em>полностью</em> и 1338 (19%) программ частично.</p>

                        <p>Основные вклады этой работы следующие:</p>
                        <ol>
                            <li>Она представляет проблему распространенных программных ошибок и предлагает сквозное
                                решение на основе глубоких сетей.</li>
                            <li>Она может итеративно исправлять несколько ошибок в одной программе.</li>
                            <li>Методика оценивается на тысячах ошибочных программ на C с обнадеживающими результатами.
                            </li>
                        </ol>
                    </div>

                    <div class="section">
                        <div class="section-title">Связанные работы</div>
                        <p>В последние годы алгоритмы глубокого обучения успешно применялись к различным задачам в
                            обработке естественного языка. Хотя между естественными языками и языками программирования
                            существуют сходства, программы характеризуются богатой структурной информацией. Hindle2012
                            исследовали регулярности в тексте программ, которые они называют "естественностью" по
                            аналогии с текстом на естественном языке. Сообщество программной инженерии успешно применило
                            глубокое обучение к таким проблемам, как извлечение API, миграция кода и категоризация кода.
                            Для получения более подробной информации мы отсылаем читателя к [22] и ссылкам в ней.</p>

                        <p>Генетическое программирование использовалось для обнаружения исправлений для программ [1, 4,
                            12]. Эти методы обычно полагаются на избыточность, присутствующую в других частях программы,
                            чтобы ограничить пространство поиска мутантов. Long2016 изучают вероятностную модель,
                            используя явно разработанные характеристики кода для ранжирования кандидатов на исправление.
                            Однако кандидаты на исправление перечисляются отдельно и не предсказываются, как в нашей
                            работе.</p>

                        <p>Популярность массовых открытых онлайн-курсов (МООК) в последнее время очевидна из большого
                            числа зарегистрировавшихся на такие курсы. Piech и др. (2015) предложили подход на основе
                            нейронных сетей для поиска представлений программ и использовали их для автоматического
                            распространения обратной связи инструктора к студентам в массовом курсе. Их подход основан
                            на архитектуре кодировщик-декодировщик и полезен особенно в дискретных задачах
                            программирования типа "gridworld". Мы рассматриваем гораздо более общий класс программ на C
                            и автоматически генерируем исправления.</p>

                        <p>Мы формулируем задачу исправления программ как задачу генерации выходной последовательности
                            (исправления) из входной последовательности (ошибочной программы). Sutskever, Vinyals и Le
                            (2014) представили модель нейронной сети для решения задачи обучения
                            "последовательность-последовательность" в рамках общей концепции нейронного машинного
                            перевода. Главный недостаток этого подхода — использование вектора фиксированной длины для
                            кодирования информации, относящейся к исходным последовательностям различной длины.
                            Bahdanau, Cho и Bengio (2014) смягчили эту проблему, предложив модель с механизмом внимания.
                            Эта модель фокусируется на наиболее релевантной информации в исходной последовательности с
                            помощью соответствующего механизма поиска и обладает способностью хорошо обрабатывать
                            зависимости на большом расстоянии. Vinyals и др. (2015) достигли передовых результатов для
                            задачи синтаксического анализа составляющих, используя эту архитектуру. Xie и др. (2016)
                            используют механизм, основанный на внимании на уровне символов, для исправления
                            естественного языка. Насколько нам известно, наше решение является первым сквозным
                            (end-to-end) решением, которое использует глубокую сеть для локализации и исправления
                            распространенных ошибок программирования.</p>
                    </div>

                    <div class="section">
                        <div class="section-title">Технические детали</div>
                        <p>В этом разделе мы обсуждаем общий дизайн DeepFix.</p>

                        <div class="subsection">
                            <div class="section-title">Представление программы</div>
                            <p>Мы формулируем задачу исправления ошибки программирования как задачу обучения
                                "последовательность-последовательность". Это требует представления программы в виде
                                последовательности. Теперь мы приведем детали нашего представления программы.</p>

                            <p>Текст программы состоит из различных типов лексем, таких как типы, ключевые слова,
                                специальные символы (например, точки с запятой), функции, литералы и переменные. Среди
                                них типы, ключевые слова, специальные символы и библиотечные функции образуют <em>общий
                                    словарь</em> для разных программ. Мы сохраняем их при представлении программы. Мы
                                моделируем другие типы лексем следующим образом. Сначала мы определяем пул имен
                                фиксированного размера, а затем создаем отдельную <em>карту кодирования</em> для каждой
                                программы, случайным образом сопоставляя каждый уникальный идентификатор (имя переменной
                                или функции) в программе с уникальным именем в нашем пуле. Мы выбираем пул, достаточно
                                большой, чтобы создать указанное сопоставление для любой программы в нашем наборе
                                данных. Это преобразование не меняет семантику программы и является обратимым.</p>

                            <p>Точные значения литералов не имеют значения для нашей задачи обучения. Поэтому мы
                                сопоставляем литерал со специальной лексемой на основе его типа, например, мы
                                сопоставляем все целочисленные литералы с NUM, а все строковые литералы с STR. Мы
                                используем специальную лексему &lt;eos&gt; для обозначения конца последовательности
                                лексем.</p>

                            <p>Мы рассматриваем программу как последовательность лексем X. Мы можем захотеть, чтобы сеть
                                сгенерировала другую последовательность Y, такую, что Y исправляет ошибки в X. Однако
                                типичная программа, которую мы рассматриваем, содержит несколько сотен лексем, и точно
                                предсказать целевую последовательность аналогичного размера сложно. Чтобы преодолеть эту
                                проблему, мы включаем <em>номера строк</em> в представление программы. Оператор S в
                                строке L программы представляется как (ℓ,s), где ℓ и s — это лексемизированные
                                представления L и S. Программа P с k строками представляется как
                                (ℓ₁,s₁),…,(ℓₖ,sₖ)&lt;eos&gt;, где ℓ₁,…,ℓₖ — это номера строк, а s₁,…,sₖ —
                                последовательности лексем для операторов в соответствующих строках.</p>

                            <p>Теперь мы можем обучить сеть предсказывать одно исправление. Исправление состоит из
                                номера строки ℓᵢ и связанного с ним оператора s′ᵢ, который исправляет ошибки в операторе
                                sᵢ. Этот выход намного меньше по сравнению со всей последовательностью, представляющей
                                исправленную программу, и, возможно, его легче предсказать. Мы вскоре обсудим, как
                                согласовать исправление с входной программой и как исправлять множественные ошибки в
                                программе.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Архитектура нейронной сети</div>
                            <p>Bahdanau и др. (2014) представили механизм внимания поверх модели
                                "последовательность-последовательность" от Sutskever и др. (2014). Их сеть состоит из
                                кодировщика RNN для обработки входной последовательности и декодера RNN с вниманием для
                                генерации выходной последовательности. Наша сеть основана на многослойном варианте из
                                Vinyals и др. (2015).</p>

                            <p>И кодировщик, и декодер RNN состоят из N stacked (многослойных) рекуррентных блоков с
                                затворами (GRU) от Cho и др. (2014). Кодировщик отображает каждую лексему во входной
                                последовательности в вещественный вектор, называемый <em>аннотацией</em>.</p>

                            <p>Скрытые состояния сети декодера инициализируются конечными состояниями сети кодировщика и
                                затем обновляются. Вектор контекста cₜ вычисляется как взвешенная сумма аннотаций
                                входной последовательности с использованием нормализованных весов. Соответствующие
                                значения энергии eₜⱼ изучаются с помощью модели мягкого выравнивания ϕ,
                                параметризованной как прямоточная сеть (feed-forward network), которая обучается
                                совместно с другими компонентами модели.</p>

                            <p>Интуитивно, эти веса или значения энергии определяют важность аннотаций относительно
                                скрытого состояния dₜ₋₁ для вычисления текущего скрытого состояния декодера dₜ.</p>

                            <p>Наконец, выход декодера dₜᴺ конкатенируется с cₜ, и результат пропускается через слой
                                аффинного преобразования, за которым следует слой softmax, чтобы предсказать наиболее
                                вероятную выходную лексему ŷₜ. Мы вычисляем перекрестную энтропию по выходам слоя
                                softmax на каждом временном шаге и суммируем их по выходной последовательности, чтобы
                                вычислить функцию потерь.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Итеративное исправление</div>
                            <p>Как обсуждалось ранее, чтобы упростить задачу предсказания, мы решили, что сеть может
                                предсказывать только одно исправление. Однако в программе может быть несколько ошибок.
                                DeepFix использует простую, но эффективную итеративную стратегию для исправления
                                множественных ошибок в программе.</p>

                            <div class="figure">
                                <img src="../../img/Статья 1 Перевод 2.png"
                                    alt="Итеративная стратегия исправления DeepFix">
                                <div class="figure-caption">Рисунок 2 – Итеративная стратегия исправления DeepFix</div>
                            </div>

                            <p>Для лексемизированного представления входной программы (ℓ₁,s₁),…,(ℓₖ,sₖ)&lt;eos&gt; сеть
                                предсказывает исправление, скажем, (ℓᵢ,s′ᵢ)&lt;eos&gt;. <em>Оракул</em> принимает это
                                исправление и входную программу и согласовывает их, чтобы создать обновленную программу.
                                Обновленная программа получается путем замены sᵢ в строке ℓᵢ на s′ᵢ. Задача оракула —
                                решить, принять исправление или нет, проверив, является ли обновленная программа лучше
                                входной. В нашем случае мы используем компилятор и принимаем исправление, если
                                обновленная программа не приводит к большему количеству сообщений об ошибках, чем
                                исходная программа.</p>

                            <p>Мы также используем некоторые эвристики, чтобы предотвратить произвольные изменения
                                входной программы. Например, оракул отвергает исправление s′ᵢ, если оно не сохраняет
                                идентификаторы и ключевые слова, присутствующие в исходном операторе sᵢ. Как только
                                исправление принято, DeepFix снова представляет обновленную программу сети. Эта
                                итеративная стратегия останавливается, когда либо:</p>
                            <ol>
                                <li>Оракул определяет, что в обновленной программе не осталось ошибок для исправления
                                </li>
                                <li>Сеть считает входную программу правильной и выдает специальную лексему "fixed"</li>
                                <li>Оракул отвергает исправление</li>
                                <li>Достигается предопределенный верхний предел числа итераций</li>
                            </ol>

                            <p>Помимо решения заменить оператор в строке, сеть может определить, что новую строку нужно
                                вставить до (или после) строки lᵢ. В этом случае она выдает lᵢ⁻ (или lᵢ⁺) вместо lᵢ.
                                Чтобы удалить строку lᵢ, она выдает lᵢ с пустой строкой ε.</p>

                            <p>Сеть работает с лексемизированным представлением программы. Поскольку мы в конечном счете
                                должны исправлять реальные программы, оракул восстанавливает текст программы из
                                последовательности лексем, полученной после применения исправления. Он использует
                                программо-специфичную карту кодирования, созданную во время лексемизации, для обратной
                                подстановки исходных идентификаторов. Он использует номер строки в исправлении и
                                заменяет специальные лексемы, такие как NUM и STR, на литералы из соответствующей строки
                                во входной программе. Если оракул не может восстановить текст программы, то он отвергает
                                исправление.</p>

                            <p>Предложенная стратегия исправления имеет несколько преимуществ:</p>
                            <ol>
                                <li>Программа представляется сети целиком. Выявление и исправление ошибок
                                    программирования обычно требует глобального анализа, способного выводить
                                    долгосрочные зависимости.</li>
                                <li>Включение номеров строк как во входные, так и в выходные данные уменьшает
                                    детализацию и, следовательно, сложность задачи предсказания.</li>
                                <li>DeepFix может итеративно исправлять множественные ошибки в программе.</li>
                                <li>Оракул используется для отслеживания прогресса и предотвращения бесполезных или
                                    произвольных изменений.</li>
                                <li>Стратегия исправления DeepFix довольно общая. Например, если бы мы попытались
                                    исправлять логические ошибки, мы могли бы использовать тестовый движок с набором
                                    тестов в качестве оракула.</li>
                            </ol>
                        </div>
                    </div>

                    <div class="section">
                        <div class="section-title-center">Эксперименты</div>

                        <div class="subsection">
                            <div class="section-title">Экспериментальная установка</div>
                            <p>Для обучения и оценки мы использовали программы на C, написанные студентами для 93
                                различных задач по программированию в вводном курсе программирования. Программы были
                                захвачены через веб-туторинговую систему [13]. Мы обучаем нейронные сети на машине
                                Intel(R) Xeon(R) E5-2640 v3 с 16 ядрами, тактовой частотой 2.60ГГц, с 125ГБ оперативной
                                памяти и оснащенной GPU-ускорителем NVIDIA Tesla K40. Чтобы работать в рамках этой
                                конфигурации машины, мы выбрали программы, длина лексем которых составляла от 100 до
                                400.</p>

                            <div class="section-title">Набор данных</div>
                            <p>У нас есть два класса программ в нашем наборе данных — программы, которые компилируются
                                (в дальнейшем <em>правильные программы</em>), и программы, которые не компилируются (в
                                дальнейшем <em>ошибочные программы</em>). Студент может отправить несколько ошибочных
                                программ. Мы случайным образом выбираем только одну ошибочную программу на студента для
                                каждой задачи программирования, чтобы избежать смещения результатов тестирования.</p>

                            <p>Чтобы дать точную оценку нашей технике, мы проводим 5-кратную перекрестную проверку,
                                оставляя примерно 1/5 задач программирования для каждого сгиба (fold). Ошибочные
                                программы, принадлежащие отложенным задачам, используются для генерации <em>сырого
                                    набора данных</em> (Таблица 1). Правильные программы из остальных задач используются
                                для генерации обучающих примеров. Мы изучили ошибочные программы в нашем наборе данных,
                                чтобы спроектировать мутации, необходимые для внедрения распространенных ошибок
                                программирования в правильные программы.</p>

                            <p>Мы изменяем до 5 операторов в каждой правильной программе, чтобы внести ошибки.
                                Измененная программа сопоставляется с исправлением для первой ошибочной строки (в
                                порядке возрастания номеров строк), и эта пара составляет один <em>обучающий
                                    пример</em>. Затем мы применяем это исправление к первой ошибочной строке и
                                продолжаем рекурсивно генерировать пары "мутант-исправление", пока все измененные строки
                                не будут исправлены. Дополнительно мы также обучаем сеть идентифицировать правильные
                                программы, обучая ее выдавать специальную лексему "fixed" в ответ на неотредактированные
                                правильные программы. Таким образом, если сеть идентифицирует программу как правильную,
                                она выдает эту специальную лексему, чтобы остановить итерационный цикл DeepFix. Чтобы
                                избежать смещения сети в сторону каких-либо задач, мы ограничиваем процесс генерации
                                обучающих данных, чтобы рассматривать только 500 правильных программ для каждой задачи.
                            </p>

                            <div class="section-title">Обучение</div>
                            <p>Мы используем архитектуру "последовательность-последовательность" на основе внимания,
                                реализованную в Tensorflow [1]. И кодировщик, и декодер в нашей сети имеют 4
                                многослойных (stacked) GRU-слоя с 300 ячейками в каждом слое. Мы используем dropout [16]
                                с вероятностью 0.2 на нерекуррентных соединениях [22]. Начальные веса берутся из
                                распределения U(−0.07,0.07), а смещения инициализируются значением 1.0. Наш словарь
                                содержит 129 уникальных лексем, каждая из которых встраивается в 50-мерный вектор.</p>

                            <p>Лексемизированное представление входной программы подается в сеть в обратном направлении.
                                Сеть обучается с использованием оптимизатора Adam [19] со скоростью обучения и
                                скоростями затухания, установленными на значения по умолчанию, и размером мини-пакета
                                128. Мы обрезаем градиенты, чтобы они оставались в диапазоне [−1,1], и обучаем сеть до
                                20 эпох. Наконец, мы выбираем обученную модель с наилучшей производительностью на
                                проверочной выборке.</p>

                            <p>Мы обучаем две сети: одну для исправления необъявленных переменных и другую для
                                исправления всех остальных ошибок. Поскольку точный идентификатор не важен для
                                последней, они представлены специальной лексемой 'ID'. Эта оптимизация снижает сложность
                                задачи предсказания исправления. В наших экспериментах мы обнаружили, что это улучшает
                                точность проверки сети до 5%. Мы запускаем две сети одновременно и для каждой итерации
                                показываем объединенные результаты обеих.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Результаты</div>
                            <p>Мы оцениваем DeepFix на сыром наборе данных следующим образом. Для каждого сгиба мы
                                рассматриваем все ошибочные студенческие программы, принадлежащие отложенным задачам в
                                этом конкретном сгибе, и оцениваем обученную модель на них.</p>

                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th colspan="4">Статистика набора данных</th>
                                            <th colspan="2">Результаты</th>
                                        </tr>
                                        <tr>
                                            <th>Набор данных</th>
                                            <th>Ошибочные<br>программы</th>
                                            <th>Ср.<br>токенов</th>
                                            <th>Сообщ.<br>об ошиб.</th>
                                            <th>Полностью<br>исправлено</th>
                                            <th>Сообщ.<br>разрешено</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Raw</td>
                                            <td>6971</td>
                                            <td>203</td>
                                            <td>16743</td>
                                            <td>1881 (27%)</td>
                                            <td>5366 (32%)</td>
                                        </tr>
                                        <tr>
                                            <td>Seeded</td>
                                            <td>9230</td>
                                            <td>206</td>
                                            <td>31783</td>
                                            <td>5185 (56%)</td>
                                            <td>19962 (63%)</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="table-caption">Таблица 1 – Сводка наборов данных и результатов</div>
                            </div>

                            <div class="section-title">Успешные исправления</div>
                            <p>DeepFix <em>полностью</em> исправляет 1881 (27%) из 6971 ошибочных программ таким
                                образом, что исправленные программы компилируются без ошибок. Он также частично
                                исправляет дополнительные 1338 (19%) программ. Изначально все программы вместе
                                сгенерировали 16743 сообщения об ошибках при компиляции с помощью GCC. Как показано в
                                Таблице 1, DeepFix устраняет 5366 (32%) сообщений об ошибках из них. DeepFix также
                                эффективен - в среднем требуется всего несколько десятков миллисекунд для исправления
                                ошибок в тестовой программе.</p>

                            <div class="section-title">Эффективность итеративного исправления</div>
                            <p>Студент может допустить несколько ошибок в программе. Итеративная стратегия DeepFix
                                пытается исправить их одну за другой. Показаны исходные ошибки для сырого набора данных,
                                отмеченные как итерация 0, а затем показано количество сообщений об ошибках, оставшихся
                                в конце каждой итерации. Мы использовали до 5 итераций. Первая итерация устраняет 4447
                                сообщений об ошибках, в то время как последующие итерации устраняют дополнительные 919
                                сообщений.</p>

                            <p>Если сеть не может создать исправление для программы на итерации, последующие итерации
                                для этой программы не выполняются, поскольку повторное применение той же сети не изменит
                                результат. Таким образом, количество программ, обрабатываемых на каждой итерации,
                                уменьшается, и, следовательно, количество исправляемых ошибок также уменьшается. Тем не
                                менее, многие программы становятся все более правильными с каждой итерацией.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Детальный анализ</div>
                            <p>Мы случайным образом выбираем до 100 правильных решений из каждой из 93 задач по
                                программированию и изменяем до 5 операторов в каждой из них, чтобы сгенерировать
                                <em>набор данных с внедренными ошибками</em> (seeded dataset). Таблица 1 дает результаты
                                для этого набора данных. Из 9230 программ DeepFix исправляет 5185 (56%) программ
                                полностью и 1534 (17%) программ частично. Из 31783 сообщений об ошибках компиляции он
                                устраняет 19962 (63%) сообщений.</p>

                            <p>В отличие от сырого набора данных, мы знаем точные исправления, ожидаемые в наборе данных
                                с внедренными ошибками. Мы используем это, чтобы лучше понять производительность
                                DeepFix.</p>

                            <div class="section-title">Локализация ошибок</div>
                            <p>Как обсуждалось ранее, компиляторы не точно локализуют ошибки. Наше решение является
                                сквозным (end-to-end), в котором сеть самостоятельно выполняет локализацию ошибок. Мы
                                оценили точность локализации нашей сети на наборе данных с внедренными ошибками. На
                                первой итерации ожидается, что она локализует первую ошибочную строку в каждой
                                программе. Из 9230 ошибочных строк она успешно локализует 7262 (78.68%).</p>

                            <p>Инструменты локализации программных ошибок обычно сообщают ранжированный список
                                потенциально ошибочных строк. С помощью beam search мы можем получить ранжированный
                                список. Из 9230 ошибочных строк 8077 строк (87.50%) появились в топ-5 ошибочных строках,
                                предсказанных сетью. Хотя мы и aim at predicting the required fixes, на практике даже
                                сообщение об ошибочных строках само по себе может быть существенной помощью
                                программистам.</p>

                            <div class="section-title">Точность на уровне лексем против точности исправления</div>
                            <p>Исправление программ — это сложная задача предсказания, поскольку предложенное
                                исправление является правильным только в том случае, если оно правильно предсказывает
                                требуемую лексему в каждой позиции выходной последовательности. Наша сеть имела точность
                                на уровне лексем 86.98%, но точность исправления только 64.97%. Первое подсчитывает
                                количество лексем из выходной последовательности, предсказанных правильно, а второе
                                подсчитывает количество выходных последовательностей, предсказанных полностью правильно.
                            </p>

                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Длина исправления (токены)</th>
                                            <th>Количество исправлений</th>
                                            <th>Точность (уровень токенов)</th>
                                            <th>Точность исправления</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>&lt;10</td>
                                            <td>3105</td>
                                            <td>90.01%</td>
                                            <td>72.43%</td>
                                        </tr>
                                        <tr>
                                            <td>10-15</td>
                                            <td>3994</td>
                                            <td>88.21%</td>
                                            <td>66.82%</td>
                                        </tr>
                                        <tr>
                                            <td>&gt;15</td>
                                            <td>2131</td>
                                            <td>80.28%</td>
                                            <td>50.63%</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="table-caption">Таблица 2 – Длина исправления vs точность исправления для
                                    набора данных с внедренными ошибками</div>
                            </div>

                            <p>Мы разделяем исправления, сгенерированные DeepFix на первой итерации, по длине
                                исправления в количестве лексем. По мере увеличения длины предсказываемого исправления
                                как точность на уровне лексем, так и точность исправления уменьшаются. Тем не менее,
                                даже для исправлений, требующих более 15 лексем, точность исправления составляет 50.63%.
                            </p>

                            <div class="section-title">Визуализация промежуточных представлений</div>
                            <p>Мы подаем 2000 программ, выбранных из сырого набора данных, в обученный кодировщик
                                DeepFix и извлекаем итоговые векторы аннотаций. Мы показываем первые две главные
                                компоненты этих векторов. Как видно, правильные и неправильные программы образуют два
                                отдельных кластера с очень небольшим перекрытием. Это указывает на то, что кодировщик
                                DeepFix учится захватывать синтаксическую корректность программ.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Обсуждение</div>
                            <p>Наши эксперименты показывают, что DeepFix успешно исправляет многие программы и типы
                                ошибок. Программы в сыром наборе данных написаны студентами в реальном курсе
                                программирования. Одна из основных причин, ограничивающих применимость DeepFix,
                                заключается в том, что исправления иногда слишком сложны для генерации сетью. Например,
                                мы наблюдали ошибки, такие как попытка присвоить один массив переменной другого массива,
                                что не разрешено в C. Исправление этого потребует предсказания цикла с поэлементным
                                присваиванием между массивами, что выходит за возможности сети.</p>

                            <p>Мы использовали синтетический обучающий набор данных. DeepFix исправляет существенно
                                больше программ в наборе данных с внедренными ошибками, чем в сыром наборе данных
                                (например, 56% полностью исправленных программ для набора данных с внедренными ошибками
                                против 27% для сырого набора данных). Это указывает на то, что наш обучающий набор
                                данных не отражает все возможные ошибки из сырого набора данных. Мы надеемся, что
                                использование лучшего обучающего набора данных может further увеличить
                                производительность DeepFix.</p>

                            <p>В некоторых случаях может быть несколько вариантов исправления ошибки; но не все они
                                могут быть приемлемы. Случайное исправление может полностью удалить ошибочную строку. Мы
                                используем оракул, чтобы предотвратить принятие DeepFix таких изменений. Хотя длина
                                исправления негативно влияет на точность исправления, мы наблюдали, что многие
                                исправления включают лишь незначительные правки строки. Мы планируем изучить подходящий
                                механизм в будущем, чтобы использовать этот факт.</p>
                        </div>
                    </div>

                    <div class="section">
                        <div class="section-title">Выводы</div>
                        <p>Мы представляем проблему распространенных ошибок программирования и предлагаем сквозное
                            (end-to-end) решение на основе глубокого обучения. Наше решение, DeepFix, исправляет
                            множественные ошибки путем итеративного вызова обученной нейронной сети. Мы оценили DeepFix
                            на 6971 ошибочной программе на C, написанной студентами. DeepFix смог исправить 27% программ
                            полностью и 19% программ частично. Хотя оценка проводилась только на программах на C, наша
                            методика не зависит от языка программирования и должна обобщаться на другие языки
                            программирования.</p>

                        <p>В будущем мы планируем применить глубокое обучение для исправления более сложных ошибок
                            программирования. Мы также планируем изучить способы улучшения производительности DeepFix. В
                            частности, мы хотим разработать архитектуры нейронных сетей, которые могут эффективно
                            обрабатывать более длинные последовательности.</p>
                    </div>

                    <div class="references">
                        <div class="section-title">Литература</div>
                        <div class="reference-list">
                            <div class="reference-item">1. Gupta, R., Pal, S., Kanade, A., & Shevade, S. (2017).
                                DeepFix: Fixing Common C Language Errors by Deep Learning. Proceedings of the AAAI
                                Conference on Artificial Intelligence.</div>
                            <div class="reference-item">2. Bahdanau, D., Cho, K., & Bengio, Y. (2014). Neural machine
                                translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473.
                            </div>
                            <div class="reference-item">3. Sutskever, I., Vinyals, O., & Le, Q. V. (2014). Sequence to
                                sequence learning with neural networks. In Advances in neural information processing
                                systems.</div>
                            <div class="reference-item">4. Vinyals, O., Kaiser, L., Koo, T., Petrov, S., Sutskever, I.,
                                & Hinton, G. (2015). Grammar as a foreign language. In Advances in neural information
                                processing systems.</div>
                            <div class="reference-item">5. Xie, Z., Avati, A., Arivazhagan, N., Jurafsky, D., & Ng, A.
                                Y. (2016). Neural language correction with character-based attention. arXiv preprint
                                arXiv:1603.09727.</div>
                            <div class="reference-item">6. Piech, C., Huang, J., Nguyen, A., Phulsuksombati, M., Sahami,
                                M., & Guibas, L. J. (2015). Learning program embeddings to propagate feedback on student
                                code. In International Conference on Machine Learning.</div>
                            <div class="reference-item">7. Long, F., & Rinard, M. (2016). Automatic patch generation by
                                learning correct code. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on
                                Principles of Programming Languages.</div>
                            <!-- Добавлены остальные ссылки из оригинала -->
                        </div>
                    </div>

                    <a href="../../science/index_ru.html" class="article-back-link">← Назад к научным трудам</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Нижнее меню -->
    <footer class="footer-menu">
        <a class="footer-item" href="../../index_ru.html">Резюме</a>
        <a class="footer-item" href="../../diss/index_ru.html">Реферат</a>
        <a class="footer-item" href="../../science/index_ru.html">Научные труды</a>
        <a class="footer-item" href="../../ind/index_ru.html">Индивидуальный раздел</a>
    </footer>

    <script src="../../js/particles-config.js"></script>
    <script src="../../js/main.js"></script>
    <script src="../../js/script.js"></script>

</body>

</html>