<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Назначение и применение паттерна Strategy и StateMachine - Павлов М.Ю., Боднар А.В.</title>
    <link rel="stylesheet" href="../../css/master_style.css">
    <link rel="stylesheet" href="../../css/article.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@1.39.0/tsparticles.min.js"></script>
</head>

<body>

    <div id="tsparticles" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></div>

    <!-- Верхний блок -->
    <div class="top-block">
        <div class="lang-box">
            <!-- <a href="article15_eng.html" class="lang-link">EN</a> -->
        </div>
        <div class="university-links">
            <a href="http://donntu.ru" target="_blank">ДонНТУ</a>
            <a href="http://masters.donntu.ru" target="_blank" title="Перейти на портал магистров ДонНТУ">Портал
                магистров</a>
        </div>
    </div>

    <!-- Основное содержимое -->
    <div class="container">
        <div class="article-container">
            <div class="article-content">
                <div class="udk">УДК 004.42</div>

                <div class="article-header">
                    <div class="article-title">
                        НАЗНАЧЕНИЕ И ПРИМЕНЕНИЕ ПАТТЕРНА STRATEGY И STATEMACHINE
                    </div>

                    <div class="authors">
                        Павлов М.Ю.<sup>1</sup>, Боднар А.В.<sup>2</sup>
                    </div>

                    <div class="university">
                        ФГБОУ ВО «Донецкий национальный технический университет» (г. Донецк)<br>
                        Кафедра программной инженерии им. Л. П. Фельдмана
                    </div>

                    <div class="contact">
                        <sup>1</sup> студент, e-mail: [email скрыт]<br>
                        <sup>2</sup> к.э.н., доцент, e-mail: [email скрыт]
                    </div>

                    <div class="abstract">
                        <p><strong>Павлов М.Ю., Боднар А.В. Назначение и применение паттерна Strategy и StateMachine.</strong> В работе рассматриваются один из базовых паттернов поведения Strategy и одно из его проявлений – StateMachine. Выделяется основа паттерна Strategy, его происхождение и основное назначение. Паттерн является инструментом, который произошел из более простого метода реализации в результате структурированного развития системы. В качестве примера приводятся математические формулы, выведенные из простых действий.</p>
                        <p class="keywords"><strong>Ключевые слова:</strong> компонентно-ориентированный подход, компоненты, разработка, проектирование, парадигма, система</p>
                        
                        <p><strong>Pavlov M.Yu., Bodnar A.V. Purpose and application of the Strategy pattern and StateMachine.</strong> The paper considers one of the basic patterns of strategy behavior and one of its manifestations – StateMachine. The basis of the strategy pattern, its origin and main purpose are highlighted. A pattern is a tool that originated from a simpler implementation method as a result of the structured development of the system. As an example, mathematical formulas derived from simple actions are given.</p>
                        <p class="keywords"><strong>Keywords:</strong> pattern, condition, principle, optimization, strategy, development, design.</p>
                    </div>

                    <div class="section">
                        <div class="section-title">Введение</div>
                        <p>Решение задач – сложная и глубокая тема. Поиск решения может охватывать как огромные области, так и быть узконаправленным. В процессе поиска решений обнаруживается типовой алгоритм или определенный шаблон, следование которому позволяет устранить проблему наиболее эффективным образом. В программировании такие шаблоны называются «паттерны проектирования».</p>
                        <p>Сами паттерны можно рассматривать как математические формулы, которые используются для преобразования, упрощения или приведения выражений. Паттерны раскрывают возможности манипуляции данными и обладают огромным потенциалом в поиске решений.</p>
                        <p>Математические преобразования хорошо отражают суть паттернов: и то, и другое можно охарактеризовать как упрощение какого-либо действия или правило, выведенное из простых, базовых конструкций. В качестве примера можно привести сокращенное умножение и описать его как процесс раскрытия скобок, повторяемый до тех пор, пока не будет получено решение. В основе паттерна всегда лежит простое действие, которое возможно повторять для выполнения более сложных действий.</p>
                        <p>Подобно тому, как в структурированной науке математике можно систематизировать определенные действия, тем самым приравнивая их к паттернам, можно описать в паттернах и то, что обладает менее системным характером. Основной темой доклада является моделирование. Так, к примеру, социальную ситуацию, где человек ведет себя по-разному в зависимости от обстоятельств (на работе он более сдержан, а с друзьями открыт) можно описать через влияние внешних факторов. Эти множественные факторы – элементы, каждый из которых обладает своим свойством. Их совокупность и определяет поведение конкретного индивида.</p>
                        <p>Рассматривая вышеописанную модель с точки зрения программирования, можно найти несколько способов решения. Один из них состоит в том, что каждый выбор человека вести себя определенным образом можно выделить в отдельный класс – класс состояния, который и будет описывать его поведение. В другом способе возможно задать поведение методами, избегая создания лишних сущностей в виде классов. В таком случае каждая вариация поведения будет описываться либо отдельным методом, либо методом с параметрами, то есть с задействованием принципа полиморфизма.</p>
                        <p>Таким образом, есть два пути: использовать класс, описывающий состояние, либо использовать методы, которые делают то же самое. Внутри созданного класса можно будет обрабатывать события, зависящие от текущего состояния объекта. Использование методов также допускает обработку состояний объекта, но с одним отличием – с атрибутами можно взаимодействовать напрямую. Здесь возникает спорная ситуация: либо использовать один перегруженный метод, либо множество методов для каждого состояния.</p>
                        <p>Оба варианта используют разный подход к реализации основного функционала, который может хорошо выполняться в одних условиях и плохо – в других. Поэтому выбор реализации алгоритмов зависит от конкретной задачи. Также немаловажную роль играет архитектура приложения, под которую подстраивается рассматриваемая ситуация.</p>
                        <p>При таком построении алгоритмов возникает вопрос об их заменимости, дальнейшем развитии приложения и необходимости реализации конкретного способа. Если для описания поведения достаточно одной функции, то разумнее написать один метод. Проще всего использовать для этого делегат, то есть переменную, имеющую тип ссылки на определенную функцию. Если же появляется необходимость во множественном использовании, дополнительных параметрах и в вариативности поведения, куда лучше обзавестись собственными классами.</p>
                        <p>Теперь же рассмотрим решение проблемы более глобально. В этом случае можно ввести некое правило, не зависящее от конкретного класса, в котором оно реализуется. Скорее, оно является описанием поведения, которое может использоваться по своему назначению. Тем самым мы приходим к приведению решения в определенный шаблон или паттерн.</p>
                        <p>Теперь, имея понимание, что из себя представляет конкретный паттерн, а именно Strategy и StateMachine (далее – стратегия и машина состояний), возникает вопрос, почему в данном случае мы рассматриваем именно два паттерна. Всё просто: на самом деле машина состояний является развитием паттерна стратегия, из-за чего имеет некоторые отличия и важные особенности в реализации, а также показывает важные аспекты стратегии.</p>
                        <p>Главное свойство паттернов – оптимальное или приближенное к оптимальному решение, но лишь в необходимых условиях. В ином случае, паттерн, скорее, будет усложнять структуру и алгоритм программного обеспечения, вызывая различные путаницы в использовании и расширении.</p>
                    </div>

                    <div class="section">
                        <div class="section-title">Основа работы паттернов</div>
                        <p>Часто при реализации программного кода специалист неосознанно использует определенные паттерны проектирования. Это будет продемонстрировано на примере паттерна «стратегия».</p>
                        <p>В основе работы паттерна лежит определение семейства определенной группы с взаимозаменяемыми алгоритмами.</p>
                        <p>Если рассматривать паттерн подробнее, то в его основе лежит принцип создания одного интерфейса, на основе которого реализуются разные алгоритмы в дочерних классах, тем самым позволяя использовать тип данных родителя, а функционал – дочерних объектов.</p>
                        <p>Тем не менее, использовать паттерн можно и для одной реализации, то есть одного алгоритма. Это необходимо для выделения алгоритма и обеспечения его важности в коде.</p>
                        <p>Важной частью при реализации одного алгоритма является использование делегата вместо выделения одного интерфейса, если мы говорим о реализации в платформе .NET.</p>
                        <p>Одной из особенностей данного паттерна является специфика: как бы ни казалось, что подобный паттерн можно обобщить и использовать в виде библиотечного кода, но это в корне неверное решение. Использование подобного пути наталкивает на усложнение посредством добавления лишних сущностей и ненужных реализаций, что в корне ломает понимание и фундамент использования паттерна.</p>
                        <p>В процессе обсуждения паттерна возникает вопрос «А зачем вообще выделять реализацию алгоритма в стратегии, если уже есть несколько алгоритмов, реализованных в методах или определяющих функционал класса?». Это здравый вопрос.</p>
                        <p>Но самой важной особенностью является не сама реализация алгоритма, а возможность спрятать его, тем самым обеспечив его заменяемость во время исполнения программного кода. Следовательно, стратегия обеспечивает возможность расширения системы в плоскости алгоритма использования, а именно – контекст класса не знает, какой вариант стратегии он будет использовать.</p>
                        <p>Теперь рассмотрим применимость стратегии. Первое, что стоит сказать – не следует использовать стратегию просто так. Наследование всегда добавляет дополнительную сложность программе, как минимум как элемент усложнения общей структуры. Но тут же возникает проблема увеличения количества сущностей, что напрямую идет вразрез с принципом замещения Лисков. Из чего можно сделать вывод, что использование подобных структур необходимо только тогда, когда появляется требуется замена поведения во время исполнения структурного кода.</p>
                        <p>Теперь, имея понимание, как работает основной паттерн, рассмотрим более подробно машину состояний.</p>
                        <p>В основе паттерна лежит, как ни странно, машина Тьюринга, ведь именно она стала первым примером использования состояний и путей переходов между ними.</p>
                        <p>Важнейшей отличительной особенностью является именно переход в другое состояние, что влечет за собой изменения поведения объекта при определенных условиях. Что извне выглядит так, словно один из классов был заменен на другой путем преобразования алгоритма. В общем, многие особенности машины состояний очень схожи со стратегией, в особенности проблемы увеличения сущностей и функционала. Но тут появляется другая проблема. Если же в случае со стратегией мы чаще обращаем внимание на сложность выполняющегося алгоритма, то в случае с машиной состояний мы смотрим на сложность конечного автомата или состояния.</p>
                        <p>Машина состояний помогает упростить управление логикой переходов, что особенно ценно в проектах с многослойной или запутанной логикой. Каждое состояние становится самостоятельной сущностью, обладающей собственными правилами перехода, что упрощает отладку и поддержку кода. В отличие от стратегии, где акцент делается на замене алгоритмов, конечный автомат организует логику так, что изменения состояния предопределяют следующий шаг.</p>
                        <p>Это не только упрощает код, делая его более читаемым, но и обеспечивает контроль над условиями и моментами перехода. Таким образом, машина состояний позволяет избежать множества ошибок и повысить устойчивость программы к изменениям.</p>
                        <p>Как правило, машину состояний используют для изменения работы флагов. В пример можно привести работу сайта и всплывающего меню с вкладками. Допустим, у нас есть подобное окно: при наведении или щелчке мышью, данное окно проигрывает анимацию открытия. Теперь нам нужно знать, открыто ли окно, но мы можем воспользоваться флагом, который, собственно, и будет показывать его состояние на текущий момент. Теперь, при частых кликах возникает стандартная проблема: у нас начинает мигать окно, поскольку анимация не успевает выполниться. Тут, казалось бы, мы можем воспользоваться тем же примером и использовать флаг. Но в таком случае мы начинаем множить сущности, и ответственность за понимание состояния полностью перетекает на этот класс. Здесь и появляется возможность использовать машину состояний.</p>
                        <p>Машина состояний – не такая сложная конструкция. Общая механика у неё такая же, как и в стратегии, что обуславливает некоторые из её особенностей. В нашем случае мы выносим несколько состояний, которые напрямую заменяют собой флаги. То есть код выполнения больше не будет зависеть от них. При работе определенного состояния выполняется переход в другое: например, мы открываем всплывающее меню, переходя из стандартного состояния в состояние анимации, а после её выполнения – в состояние открытое окно. Тем самым машина состояний превращается в интересную машину, которую можно использовать для реализации и подчинения различных структур, избавляясь от дополнительных вложений благодаря использованию конструкций.</p>
                    </div>

                    <div class="section">
                        <div class="section-title">Выводы</div>
                        <p>В заключение стоит сказать, что паттерны проектирования – очень сильный инструмент, который может помочь в решении многих проблем, в том числе решить вопросы архитектуры, систематизировать вопрос будущего расширения программы и использоваться как способ решения упрощения вложенной логики, замены флагов и др.</p>
                        <p>В нашем случае, были рассмотрены два паттерна, которые имеют огромную область применения, тем не менее, они и обладают негативным аспектом в виде ненужного усложнения кода при неправильном понимании основ использования, что позволяет сделать следующий вывод: инструменты нужно применять там, где они необходимы.</p>
                        <p>Таким образом, важно помнить, что даже самые полезные паттерны проектирования не являются универсальным решением для всех задач. Применение каждого паттерна требует глубокого анализа и понимания контекста, в котором он используется, чтобы избежать излишней сложности, поддерживая баланс между гибкостью кода и его читабельностью.</p>
                    </div>

                    <div class="references">
                        <div class="section-title">Список источников</div>
                        <div class="reference-list">
                            <div class="reference-item">1. Тепляков, С. Паттерны проектирования на платформе .NET / Тепляков С. – СПБ: Питер 2015 – 320 с.</div>
                            <div class="reference-item">2. Гамма, Э. Приёмы объектно-ориентированного проектирования. Паттерны проектирования / Гамма Э., Хелм Р., Джонсон Р., Блиссидес – СПБ.: Питер, 2016 – 368 с.</div>
                            <div class="reference-item">3. Фримен, Э. Паттерны проектирования. / Фримен. Э., Робсон. Э., Снерра. К., Берт. Б. – СПБ.: Питер, 2018 -656 с.</div>
                            <div class="reference-item">4. Мейер, Б. Объектно-ориентированное конструирование программных систем / Мейер. Б. Москва: ”Русская редакция”,2005 – 1204 с.</div>
                            <div class="reference-item">5. Фаулер, М. Рефакторинг. Улучшение проекта существующего кода / Фаулер. М. Пер. с англ. – СПб: Символ-Плюс, 2003. – 432 с.</div>
                        </div>
                    </div>

                    <a href="../../science/index.html" class="article-back-link">← Назад к научным трудам</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Нижнее меню -->
    <footer class="footer-menu">
        <a class="footer-item" href="../../index.html">Резюме</a>
        <a class="footer-item" href="../../diss/index.html">Реферат</a>
        <a class="footer-item" href="../../science/index.html">Научные труды</a>
        <a class="footer-item" href="../../ind/index.html">Индивидуальный раздел</a>
    </footer>

    <script src="../../js/particles-config.js"></script>
    <script src="../../js/main.js"></script>
    <script src="../../js/script.js"></script>

</body>

</html>