<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Автоматическая генерация исправлений, обученная на человеческих патчах - Синяева Элеонора Витальевна</title>
    <link rel="stylesheet" href="../../css/master_style.css">
    <link rel="stylesheet" href="../../css/article.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@1.39.0/tsparticles.min.js"></script>
</head>

<body>

    <div id="tsparticles" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></div>

    <!-- Верхний блок -->
    <div class="top-block">
        <div class="lang-box">
            <!-- <a href="article_eng2.html" class="lang-link">EN</a> -->
        </div>
        <div class="university-links">
            <a href="http://donntu.ru" target="_blank">ДонНТУ</a>
            <a href="http://masters.donntu.ru" target="_blank" title="Перейти на портал магистров ДонНТУ">Портал
                магистров</a>
        </div>
    </div>

    <!-- Основное содержимое -->
    <div class="container">
        <div class="article-container">
            <div class="article-content">
               

                <div class="article-header">
                    <div class="article-title">
                        АВТОМАТИЧЕСКАЯ ГЕНЕРАЦИЯ ИСПРАВЛЕНИЙ, ОБУЧЕННАЯ НА ЧЕЛОВЕЧЕСКИХ ПАТЧАХ
                    </div>

                    <div class="authors">
                        Dongsun Kim<sup>1</sup>, Jaechang Nam<sup>1</sup>, Jaewoo Song<sup>1</sup>, and Sunghun
                        Kim<sup>1</sup>
                    </div>

                    <div class="university">
                        The Hong Kong University of Science and Technology, China
                    </div>

                    <div class="contact">
                        <sup>1</sup> {darkrsw,jcnam,jsongab,hunkim}@cse.ust.hk
                    </div>

                    <div class="abstract">
                        <p><strong>Ким Д., Нам Дж., Сон Дж., Ким С. Автоматическая генерация исправлений, обученная на
                                человеческих патчах.</strong> Генерация исправлений (patch generation) — это важная
                            задача сопровождения программного обеспечения, поскольку большинство программных систем
                            неизбежно содержат ошибки, которые нужно исправлять. К сожалению, человеческих ресурсов
                            часто недостаточно, чтобы исправить все известные и зарегистрированные ошибки. Для решения
                            этой проблемы были предложены несколько методов автоматической генерации исправлений. В
                            частности, основанный на генетическом программировании метод автоматической генерации
                            исправлений GenProg, предложенный Weimer и др., показал многообещающие результаты. Однако
                            эти методы могут порождать бессмысленные исправления из‑за случайного характера операций
                            мутации.</p>
                        <p>Чтобы преодолеть это ограничение, мы предлагаем новый подход к генерации исправлений —
                            Pattern-based Automatic program Repair (PAR) — основанный на шаблонах исправлений,
                            извлечённых из уже существующих исправлений, написанных людьми. Мы вручную проанализировали
                            более 60 000 человеческих патчей и обнаружили, что в них присутствует ряд общих шаблонов
                            исправлений. Наш подход использует эти шаблоны для автоматического порождения программных
                            исправлений.</p>
                        <p>Мы экспериментально оценили PAR на 119 реальных ошибках. Кроме того, исследование с участием
                            89 студентов и 164 разработчиков показало, что исправления, сгенерированные нашим подходом,
                            более приемлемы, чем исправления, сгенерированные GenProg. PAR успешно сгенерировал
                            исправления для 27 из 119 ошибок, тогда как GenProg — только для 16 ошибок.</p>
                        <p class="keywords"><strong>Ключевые слова:</strong> автоматическая генерация исправлений,
                            паттерны исправлений, программное обеспечение, сопровождение программ, исправление ошибок
                        </p>
                    </div>

                    <div class="section">
                        <div class="section-title">Введение</div>
                        <p>Генерация исправлений — важнейшая задача сопровождения программного обеспечения, так как
                            большинство программных систем неизбежно содержат ошибки, которые необходимо исправлять [1],
                            [2]. К сожалению, человеческих ресурсов часто недостаточно для того, чтобы создавать
                            исправления [3], даже для уже известных ошибок. Например, Windows 2000 была выпущена с более
                            чем 63 000 известными ошибками, в значительной мере из‑за ограниченности ресурсов [4].</p>

                        <p>Чтобы сократить ручной труд, было предложено несколько методов автоматической генерации
                            исправлений. Arcuri и Yao предложили идею применения эволюционных алгоритмов для
                            автоматической генерации исправлений [5]. Dallmeier и др. предложили подход на основе модели
                            поведения объектов и применили его к реальным ошибкам в проектах с открытым исходным кодом
                            [6]. Weimer и др. предложили популяционный метод [7], [8], использующий генетическое
                            программирование [9]. Wei и др. предложили основанный на контрактах подход к автоматизации
                            генерации исправлений и показали его полезность на примере ошибок в классах Eiffel [10].</p>

                        <p>Среди этих работ особенно выделяется отмеченный наградой метод генерации исправлений GenProg
                            [7] и его расширение [8], показавший наиболее многообещающие результаты. Для исправления
                            ошибки в программе эта техника генерирует варианты программы с помощью операций кроссовера и
                            мутаций, таких как добавление, замена и удаление операторов [9]. Затем она запускает тесты
                            для оценки каждого варианта. GenProg повторяет эти шаги, пока один из вариантов не пройдёт
                            все тесты. Любой вариант программы, прошедший все тесты, считается успешным исправлением.
                        </p>

                        <div class="code-block">
                            <pre>Алгоритм 1. Генерация патчей с использованием шаблонов исправлений в PAR

Вход : функция пригодности Fit: Program → R
Вход : T: множество шаблонов исправлений
Вход : PopSize: размер популяции
Выход: Patch: вариант программы, проходящий все тесты

1  пусть Pop ← initialPopulation(PopSize);
2  повторять
3      пусть Pop ← apply(Pop, T);
4      пусть Pop ← select(Pop, PopSize, Fit);
5  пока не существует Patch в Pop, который проходит все тесты;
6  вернуть Patch</pre>
                        </div>

                        <div class="code-block">
                            <pre>1918 if (lhs == DBL_MRK) lhs = ...;
1919 if (lhs == undefined) {
1920   lhs = strings[getShort(iCode, pc + 1)];
1921 }
1922 Scriptable calleeScope = scope;</pre>
                            <div class="code-caption">(a) Ошибочная программа. Строка 1920 выбрасывает исключение Array
                                Index Out of Bound, когда getShort(iCode, pc + 1) больше либо равен strings.length или
                                меньше 0.</div>
                        </div>

                        <div class="code-block">
                            <pre>1918 if (lhs == DBL_MRK) lhs = ...;
1919 if (lhs == undefined) {
1920+  lhs = ((Scriptable)lhs).getDefaultValue(null);
1921 }
1922 Scriptable calleeScope = scope;</pre>
                            <div class="code-caption">(b) Исправление, сгенерированное GenProg.</div>
                        </div>

                        <div class="code-block">
                            <pre>1918 if (lhs == DBL_MRK) lhs = ...;
1919 if (lhs == undefined) {
1920+  i = getShort(iCode, pc + 1);
1921+  if (i != -1)
1922+    lhs = strings[i];
1923 }
1924 Scriptable calleeScope = scope;</pre>
                            <div class="code-caption">(c) Исправление, написанное человеком.</div>
                        </div>

                        <div class="code-block">
                            <pre>1918 if (lhs == DBL_MRK) lhs = ...;
1919 if (lhs == undefined) {
1920+  if (getShort(iCode, pc + 1) < strings.length &&
        getShort(iCode, pc + 1) >= 0)
1921+  {
1922     lhs = strings[getShort(iCode, pc + 1)];
1923+  }
1924 }
1925 Scriptable calleeScope = scope;</pre>
                            <div class="code-caption">(d) Исправление, сгенерированное PAR.<br>
                                Рис. 1. Исправления, созданные GenProg, человеком-разработчиком и
                                PAR для ошибки Mozilla Bug #114493.
                            </div>
                        </div>


                        <p>Однако у GenProg существует принципиальное ограничение: так как этот метод в основном
                            опирается на случайные мутации программ (добавление, замена и удаление операторов), он может
                            порождать бессмысленные исправления. На рис. 1(b) показан пример такого бессмысленного
                            исправления, сгенерированного GenProg для ошибки, приведённой на рис. 1(a). По сравнению с
                            исправлением, написанным человеком (рис. 1(c)), исправление GenProg полностью убрало
                            переменную strings[] из программы. Заметим, что исходная программа должна была присваивать
                            переменной lhs элемент массива strings, если индекс корректен, тогда как исправление GenProg
                            этого не делает. Хотя патч GenProg проходит все имеющиеся тесты, разработчики не примут его,
                            что показано в разделе IV‑C.</p>

                        <div class="code-block">
                            <pre>3561 public ITextHover getCurrentTextHover() {
3562+   if (fTextHoverManager == null)
3563+       return null;
3564   return fTextHoverManager.getCurrentTextHover();
3565 }</pre>
                            <div class="code-caption">Рис. 2. Пример шаблона «проверка на null» (Null Checker) для
                                устранения ошибок Null Pointer Exception. Этот патч исправляет ошибку в TextViewer.java,
                                описанную в Eclipse JDT Bug #26028. Он вставляет оператор if, чтобы избежать вызова
                                getCurrentTextHover(), когда fTextHoverManager равен null.</div>
                        </div>

                        <p>Чтобы преодолеть это ограничение, мы предлагаем новый метод генерации исправлений:
                            Pattern-based Automatic program Repair (PAR). Этот подход использует знания о патчах,
                            написанных людьми. Сначала мы детально проанализировали 62 656 человеческих патчей из
                            проектов с открытым исходным кодом. Примечательно, что мы обнаружили несколько часто
                            встречающихся шаблонов исправлений. Основываясь на этих наблюдениях, мы создали 10 шаблонов
                            исправлений (fix templates) — это автоматические сценарии редактирования программы,
                            основанные на выявленных шаблонах. PAR использует эти шаблоны для генерации программных
                            исправлений. Хотя создание шаблонов требует ручных усилий, это одноразовый затратный шаг, а
                            сами шаблоны затем многократно переиспользуемы в разных контекстах. На рис. 1(d) показан
                            патч, сгенерированный нашим подходом, который похож на патч, написанный человеком (рис.
                            1(c)).</p>

                        <p>Для оценки PAR мы применили его к 119 реальным ошибкам, собранным из проектов с открытым
                            исходным кодом, включая Apache log4j¹, Rhino² и AspectJ³.</p>

                        <p>Мы попросили 253 участников (89 студентов и 164 разработчиков) сравнить, какие исправления
                            они бы приняли, если бы выступали в роли ревьюеров кода для анонимизированных патчей,
                            созданных PAR и GenProg. Результаты ясно показали, что исправления, сгенерированные PAR,
                            значительно более приемлемы, чем исправления GenProg. Кроме того, наш подход сгенерировал
                            больше успешных исправлений: PAR успешно создал 27 исправлений из 119 ошибок, в то время как
                            GenProg — 16 исправлений.</p>

                        <p>В целом эта статья вносит следующие вклады:</p>
                        <ol>
                            <li>Ручной анализ человеческих исправлений. Наше исследование патчей, написанных людьми,
                                показало, что в них существуют общие шаблоны исправлений.</li>
                            <li>PAR — автоматический метод генерации исправлений, использующий шаблоны. Мы предлагаем
                                новый автоматический метод генерации исправлений, использующий шаблоны, выведенные из
                                общих шаблонов исправлений.</li>
                            <li>Эмпирическая оценка. Мы представляем результаты эмпирической оценки, применяя PAR к 119
                                реальным ошибкам.</li>
                        </ol>
                        <p>Оставшаяся часть статьи организована следующим образом. В разделе II представлены общие
                            шаблоны исправлений, выделенные из человеческих патчей. В разделе III мы описываем наш
                            подход PAR. В разделе IV приводится эмпирическая оценка, а в разделе V обсуждаются
                            ограничения подхода. В разделе VI рассматриваются связанные работы, и в разделе VII мы
                            подводим итоги и обозначаем направления будущих исследований.</p>
                    </div>

                    <div class="section">
                        <div class="section-title">Общие шаблоны исправлений</div>
                        <p>В этом разделе мы представляем общие шаблоны исправлений, выявленные в результате ручного
                            исследования человеческих патчей. Сначала мы опишем, как собирали и анализировали большое
                            количество человеческих патчей. Затем приведём перечень распространённых шаблонов
                            исправлений.</p>

                        <div class="subsection">
                            <div class="section-title">Сбор патчей</div>
                            <p>Для нашего исследования были собраны 62 656 человеческих патчей из Eclipse JDT⁴. Мы
                                выбрали Eclipse JDT, поскольку этот проект имеет длинную историю ревизий (более 10 лет)
                                и широко используется в научной литературе [11], [12]. Для получения патчей мы применили
                                фреймворк Kenyon [13], чтобы извлечь исправления ошибок [14].</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Выделение общих патчей</div>
                            <p>Поскольку наша цель — исследовать человеческие знания в генерации исправлений, мы
                                фокусировались на семантических, а не синтаксических изменениях [15]. Во‑первых, мы
                                проверяли, были ли какие‑либо семантики добавлены или удалены в патчах. Во‑вторых, мы
                                определяли корневую причину каждой ошибки и способ её устранения в соответствующем
                                патче. Наконец, похожие патчи группировались в общие шаблоны.</p>

                            <p>Чтобы сократить время ручного анализа, мы сначала группировали похожие патчи с
                                использованием groums [16]. Groum — это графовая модель для представления использования
                                объектов. Хотя она изначально не предназначалась для анализа патчей, groums помогает
                                выявлять семантические, а не синтаксические различия. Для каждого патча мы строили два
                                groum‑графа для двух последовательных версий программы — до и после применения патча.
                                Затем автоматически вычислялись различия по вершинам и рёбрам между двумя groum‑графами.
                                Патчи с одинаковыми различиями собирались в одну группу. Хотя группа патчей не
                                обязательно соответствует шаблону исправлений, такое групповое выделение существенно
                                сокращает время ручного анализа.</p>

                            <p>Для выделения шаблонов исправлений мы сначала классифицировали патчи как аддитивные,
                                субтрактивные и изменяющие (altering).</p>
                            <ul>
                                <li>Аддитивные патчи вставляют новые семантические элементы, например новые ветвления
                                    управления.</li>
                                <li>Субтрактивные патчи удаляют семантические элементы.</li>
                                <li>Изменяющие патчи только изменяют существующий поток управления, заменяя одни
                                    семантические элементы другими.</li>
                            </ul>
                            <p>Затем мы изучали корневые причины ошибок и то, как соответствующие патчи конкретно
                                устраняли эти ошибки. Например, патч на рис. 2 вставляет новый оператор if, чтобы
                                предотвратить падение, когда fTextHoverManager равен null. В этом случае корневая
                                причина — «нулевое значение», а патч исправляет её путём вставки новой ветки управления.
                            </p>

                            <p>Некоторые патчи устраняют сразу несколько причин; такие патчи мы называем композитными
                                [17]. Мы делили композитный патч на несколько независимых фрагментов и анализировали их
                                по отдельности.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Шаблоны исправлений</div>
                            <p>После анализа патчей мы выявили множество повторяющихся, похожих исправлений, то есть
                                шаблонов исправлений. В таблице I показаны общие шаблоны, выявленные в нашем
                                исследовании. Эти восемь наиболее распространённых шаблонов покрывают почти 30% всех
                                наблюдавшихся патчей. Ниже описаны детали каждого шаблона:</p>

                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Шаблоны исправлений</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Изменение параметров метода</td>
                                        </tr>
                                        <tr>
                                            <td>Вызов другого метода с теми же параметрами</td>
                                        </tr>
                                        <tr>
                                            <td>Вызов другой перегруженной версии метода с дополнительным параметром
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>Изменение условия ветвления</td>
                                        </tr>
                                        <tr>
                                            <td>Добавление проверки на null</td>
                                        </tr>
                                        <tr>
                                            <td>Инициализация объекта</td>
                                        </tr>
                                        <tr>
                                            <td>Добавление проверки границ массива</td>
                                        </tr>
                                        <tr>
                                            <td>Добавление проверки приведения типа (class cast checker)</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="table-caption">Таблица I – Общие шаблоны исправлений, обнаруженные в патчах
                                    Eclipse JDT</div>
                            </div>

                            <p><strong>Шаблон: Изменение параметров метода.</strong></p>
                            <p><strong>Пример:</strong> obj.method(v1, v2) → obj.method(v1, v3)</p>
                            <p><strong>Описание:</strong> Такой шаблон может исправить ошибку, поскольку заставляет
                                вызывающий код передавать методу корректные параметры.</p>

                            <p><strong>Шаблон: Вызов другого метода с теми же параметрами.</strong></p>
                            <p><strong>Пример:</strong> obj.method1(param) → obj.method2(param)</p>
                            <p><strong>Описание:</strong> Шаблон меняет вызываемый метод в операторе вызова, чтобы
                                исправить некорректный вызов метода.</p>

                            <p><strong>Шаблон: Вызов другой перегруженной версии метода с дополнительным
                                    параметром.</strong></p>
                            <p><strong>Пример:</strong> obj.method(v1) → obj.method(v1, v2)</p>
                            <p><strong>Описание:</strong> Этот шаблон добавляет ещё один параметр к существующему вызову
                                метода, фактически заменяя его на другую перегруженную версию.</p>

                            <p><strong>Шаблон: Изменение условия ветвления.</strong></p>
                            <p><strong>Пример:</strong> if (a == b) → if (a == b && c != 0)</p>
                            <p><strong>Описание:</strong> Шаблон изменяет условие ветвления в операторе if или тернарном
                                операторе. Часто патчи в этом шаблоне просто добавляют или удаляют терм в предикате.</p>

                            <p><strong>Шаблон: Инициализация объекта.</strong></p>
                            <p><strong>Пример:</strong> Type obj; → Type obj = new Type()</p>
                            <p><strong>Описание:</strong> Шаблон вставляет дополнительную инициализацию для объекта. Это
                                предотвращает ситуацию, когда объект равен null.</p>

                            <p><strong>Шаблон: Добавление проверок на null, выход за границы массива и неверное
                                    приведение типа.</strong></p>
                            <p><strong>Пример:</strong> obj.m1() → if (obj != null) { obj.m1(); }</p>
                            <p><strong>Описание:</strong> Эти три шаблона вставляют новый поток управления в программу.
                                Часто они добавляют новый оператор if(...), чтобы избежать выбрасывания исключений,
                                вызванных неожиданным состоянием программы. На рис. 2 показан пример такого шаблона.</p>

                            <p>В целом мы обнаружили, что в человеческих патчах существуют общие шаблоны исправлений.
                                Поскольку эти основные шаблоны используются во многих реальных патчах (около 30%) для
                                устранения ошибок, использование их в автоматической генерации исправлений потенциально
                                позволяет создавать больше успешных патчей.</p>
                        </div>
                    </div>

                    <div class="section">
                        <div class="section-title">PAR: шаблонно‑ориентированное автоматическое исправление программ
                        </div>
                        <p>PAR автоматически генерирует исправляющие патчи, используя шаблоны исправлений, описанные в
                            разделе II‑C. На рис. 3 показана общая схема нашего подхода. Когда сообщается об ошибке:</p>
                        <ol>
                            <li>PAR сначала определяет расположения ошибок, т. е. подозрительные операторы, используя
                                существующие методы локализации дефектов [8]. Эти местоположения и их ближайший контекст
                                модифицируются для исправления ошибки.</li>
                            <li>PAR использует шаблоны исправлений для генерации вариантов программы (кандидатов в
                                патчи), редактируя исходный код вокруг найденных мест.</li>
                            <li>Варианты программы оцениваются с помощью функции пригодности (fitness), которая
                                вычисляет число тестов, пройденных данным кандидатом. Если кандидат проходит все тесты,
                                мы считаем его успешным исправлением [7]. В противном случае PAR повторяет шаги
                                генерации и оценки кандидатов.</li>
                        </ol>

                        <p>Наш подход использует эволюционные вычислительные техники [9] для генерации исправлений.
                            Эволюционное вычисление — это итеративный процесс, в котором популяция вариантов
                            порождается, оценивается и отбирается. Один цикл этих трёх шагов называется поколением.</p>

                        <div class="code-block">
                            <pre>Алгоритм 1. Генерация патчей с использованием шаблонов исправлений в PAR

Вход : функция пригодности Fit: Program → R
Вход : T: множество шаблонов исправлений
Вход : PopSize: размер популяции
Выход: Patch: вариант программы, проходящий все тесты

1  пусть Pop ← initialPopulation(PopSize);
2  повторять
3      пусть Pop ← apply(Pop, T);
4      пусть Pop ← select(Pop, PopSize, Fit);
5  пока не существует Patch в Pop, который проходит все тесты;
6  вернуть Patch</pre>
                        </div>

                        <p>Наш подход сначала принимает функцию пригодности, набор шаблонов исправлений и размер
                            популяции. После создания начальной популяции вариантов программы, численность которой равна
                            размеру популяции (строка 1), он повторяет два шага: генерацию новых вариантов с помощью
                            шаблонов (строка 3, репродукция) и отбор лучших вариантов по функции пригодности (строка 4,
                            оценка и отбор). Итерация прекращается, когда хотя бы один вариант проходит все тесты
                            (строка 5) или когда выполняются заранее заданные условия остановки (см. раздел IV‑A).
                            Алгоритм 1 возвращает вариант программы, прошедший все тесты, как успешный патч (строка 6).
                        </p>

                        <p>Мы используем эволюционный процесс, поскольку он показал эффективность при автоматической
                            генерации исправлений [8], позволяя эффективно исследовать большое пространство вариантов
                            программ. Применение эволюционных алгоритмов к ремонту программ было впервые предложено
                            Weimer и др. [7] и Arcuri и др. [5].</p>

                        <p>В оставшейся части раздела мы детально опишем локализацию дефектов, шаблоны исправлений и
                            функцию пригодности, используемые в PAR.</p>

                        <div class="subsection">
                            <div class="section-title">Локализация дефектов</div>
                            <p>Чтобы определить местоположения ошибок, PAR использует статистическую локализацию
                                дефектов, основанную на тестах [8]. Этот метод предполагает, что оператор, который
                                выполняется в неуспешных тестах, более вероятно содержит дефект, чем другие операторы. В
                                частности, техника присваивает каждому оператору программы значение, представляющее
                                степень подозрительности. Наш подход использует это значение, чтобы решить, следует ли
                                модифицировать данный оператор.</p>

                            <p>Этот метод локализации сначала запускает две группы тестов: успешные и провалившиеся.
                                Затем он записывает покрытие операторов для обеих групп. Сравнение покрытия для каждого
                                оператора даёт один из четырёх результатов:</p>
                            <ol>
                                <li>оператор покрывается обеими группами;</li>
                                <li>покрывается только успешной группой;</li>
                                <li>только неуспешной группой;</li>
                                <li>не покрывается ни одной группой.</li>
                            </ol>
                            <p>Мы присваиваем:</p>
                            <ul>
                                <li>0.1 — операторам первого случая,</li>
                                <li>1.0 — операторам третьего случая,</li>
                                <li>0.0 — остальным.</li>
                            </ul>
                            <p>Наш подход использует эти значения для определения вероятности редактирования каждого
                                оператора. Например, значение 1.0 означает, что оператор всегда будет редактироваться, а
                                0.1 — редактируется в среднем один раз на 10 поколений.</p>

                            <p>Мы применили простую технику локализации дефектов, использованную в [8], но вместо неё
                                можно использовать и другие методы локализации, чтобы определять, какие операторы надо
                                изменять.</p>
                        </div>
                        <div class="figure">
                            <img src="../../img/Статья 2 Перевод 6.jpg"
                                alt="Рис. 3: Обзор нашего подхода к исправлению программ на основе шаблонов (PAR). Сначала PAR принимает программу с ошибкой и (a) определяет местоположения дефектов. Затем (b) он генерирует варианты программ, используя шаблоны исправлений, которые представляют собой скрипты редактирования программ, полученные из распространенных шаблонов патчей (Раздел II-C). Шаблоны изменяют исходный код в области местоположений дефектов. Эти варианты являются кандидатами в патчи. Наконец, (c) кандидаты в патчи оцениваются с использованием тестовых случаев. Если кандидат проходит все тестовые случаи, мы предполагаем, что это патч для исправления ошибки. В противном случае наш подход повторяет шаги (b) и (c) для генерации следующего патча.">
                            <div class="code-caption">Рисунок 3 – Обзор нашего подхода к исправлению программ
                                на основе шаблонов (PAR). Сначала PAR принимает программу с ошибкой и (a) определяет
                                местоположения дефектов. Затем (b) он генерирует варианты программ, используя шаблоны
                                исправлений, которые представляют собой скрипты редактирования программ, полученные из
                                распространенных шаблонов патчей (Раздел II-C). Шаблоны изменяют исходный код в области
                                местоположений дефектов. Эти варианты являются кандидатами в патчи. Наконец, (c)
                                кандидаты в патчи оцениваются с использованием тестовых случаев. Если кандидат проходит
                                все тестовые случаи, мы предполагаем, что это патч для исправления ошибки. В противном
                                случае наш подход повторяет шаги (b) и (c) для генерации следующего патча.</div>
                        </div>
                        <div class="code-block">
                            <pre>1  [Null Pointer Checker]
2  P = program
3  B = fault location
4
5  <AST Analysis>
6  C ← collect object references (method invocations,
      field accesses, and qualified names) of B in P
7
8  <Context Check>
9  if there is any object references in C ⇒ continue
10 otherwise ⇒ stop
11
12 <Program Editing>
13 insert an if() statement before B
14
15 loop for all objects in C {
16     insert a conditional expression that checks whether a
       given object is null
17 }
18 concatenate conditions by using AND
19
20 if B includes return statement {
21     negate the concatenated conditional expression
22     insert a return statement that returns a default value
       into THEN section of the if() statement
23     insert B after the if() statement
24 } else {
25     insert B into THEN section of the if() statement
26 }</pre>
                            <div class="code-caption">Рис. 4. Шаблон исправления «Проверка на null pointer»</div>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Шаблоны исправлений</div>
                            <p>Шаблоны исправлений — это сценарии редактирования программы, переписывающие абстрактное
                                синтаксическое дерево (AST). Каждый шаблон определяет три шага редактирования программы:
                            </p>
                            <ol>
                                <li>анализ AST,</li>
                                <li>проверка контекста,</li>
                                <li>редактирование программы.</li>
                            </ol>
                            <p>На шаге анализа AST сканируется дерево программы и анализируется заданная позиция дефекта
                                и её окрестность. На шаге проверки контекста определяется, можно ли отредактировать
                                программу с помощью данного шаблона, исходя из результата анализа AST. Если это
                                возможно, PAR переписывает AST программы согласно предопределённому сценарию
                                редактирования (шаг редактирования программы).</p>

                            <p>В этом разделе мы сначала опишем, как создаются и применяются шаблоны исправлений, а
                                затем приведём список шаблонов, используемых в PAR.</p>

                            <div class="subsubsection">
                                <div class="section-title">Создание шаблонов исправлений</div>
                                <p>Сначала мы внимательно изучили патчи каждого шаблона (см. таблицу I). Поскольку патчи
                                    изменяют AST программы, мы можем вычислить различия AST до и после применения патча.
                                    Эти различия мы преобразуем в сценарии редактирования в шаблоне исправлений.
                                    Заметим, что патчи одного и того же шаблона могут иметь различные AST, хотя их
                                    семантические изменения идентичны. Мы стараемся обобщить эти изменения в шаблонах,
                                    выделяя наиболее часто встречающиеся изменения.</p>

                                <p>Для шага проверки контекста мы извлекаем из патчей информацию о контексте (например,
                                    наличие обращения к массиву), нужную для проверки, может ли наш подход применить
                                    данный шаблон к программе. Затем мы добавляем в шаблон шаг анализа AST, который
                                    сканирует AST программы в точке дефекта и извлекает необходимые элементы AST, такие
                                    как имена и типы переменных. Мы определяем эти элементы, анализируя шаблоны
                                    исправлений; далее они используются в шагах проверки контекста и редактирования
                                    программы.</p>

                                <p>Например, шаблон Null Pointer Checker показан на рис. 4. Он выведен из шаблона
                                    «Добавление проверки на null», описанного в разделе II‑C. Чтобы создать этот шаблон,
                                    мы сначала обобщили, как патчи данного шаблона преобразуют AST. В общем случае они
                                    вставляют оператор if() вокруг места дефекта. Подробный сценарий редактирования
                                    указан в строках 13–26 (шаг редактирования). Затем мы определяем общую контекстную
                                    информацию, которая необходима для редактирования и будет включена в шаг проверки
                                    контекста. Для этого шаблона шаг проверки контекста убеждается, что в месте дефекта
                                    есть хотя бы одна ссылочная переменная‑объект (строки 9–10). Наконец, мы добавляем
                                    шаг анализа AST (строка 6), который собирает все ссылки на объекты в месте дефекта.
                                </p>

                                <p>Аналогичным образом мы создали 10 шаблонов исправлений, показанных в таблице II. Хотя
                                    создание шаблонов требует ручных усилий, это одноразовая работа, а сами шаблоны
                                    затем можно переиспользовать для исправления других, похожих ошибок. Наша оценка в
                                    разделе IV подтверждает, что шаблоны, созданные на основе исправлений Eclipse JDT,
                                    могут успешно применяться для исправления ошибок в других программах, например
                                    Rhino.</p>
                            </div>

                            <div class="subsubsection">
                                <div class="section-title">Применение шаблонов исправлений</div>
                                <p>PAR применяет шаблон к месту дефекта в каждом поколении. Как указано в разделе III‑A,
                                    каждое место дефекта имеет вероятность выбора, и PAR использует эту вероятность для
                                    решения, какие места будут изменены данным шаблоном. Поскольку подход следует
                                    эволюционному процессу, одно место может редактироваться разными шаблонами в
                                    нескольких поколениях.</p>

                                <p>При применении шаблона PAR получает на вход программу и место дефекта. Затем он
                                    выполняет шаг анализа AST в шаблоне, чтобы собрать необходимую информацию (типы
                                    переменных, параметры методов и т.п.). Используя эту информацию, PAR запускает шаг
                                    проверки контекста, чтобы определить, подходит ли программа для применения данного
                                    шаблона. Если проверка контекста пройдена, PAR выполняет шаг редактирования —
                                    переписывает AST программы в месте дефекта. Переписывание AST может включать
                                    добавление узлов, замену параметров, удаление предикатов и т.д. Модифицированная
                                    программа является новым вариантом, который PAR рассматривает как кандидата в патчи.
                                </p>

                                <p>Возможна ситуация, когда несколько шаблонов проходят проверку контекста для одного и
                                    того же места дефекта. В этом случае PAR случайным образом выбирает один из них.</p>
                            </div>

                            <div class="subsubsection">
                                <div class="section-title">Список шаблонов исправлений</div>

                                <div class="table-container">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Имя шаблона</th>
                                                <th>Описание</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>Parameter Replacer</td>
                                                <td>Для вызова метода шаблон ищет в той же области видимости переменные
                                                    или выражения с типом, совместимым с типом параметра метода. Затем
                                                    он заменяет выбранный параметр совместимой переменной или
                                                    выражением.</td>
                                            </tr>
                                            <tr>
                                                <td>Method Replacer</td>
                                                <td>Для вызова метода шаблон заменяет его на другой метод с совместимыми
                                                    параметрами и возвращаемым типом.</td>
                                            </tr>
                                            <tr>
                                                <td>Parameter Adder and Remover</td>
                                                <td>Для вызова метода шаблон добавляет или удаляет параметры, если у
                                                    метода есть перегруженные версии. При добавлении параметра шаблон
                                                    ищет совместимые переменные и выражения в той же области видимости и
                                                    добавляет одно из них на место нового параметра.</td>
                                            </tr>
                                            <tr>
                                                <td>Expression Replacer</td>
                                                <td>Для условного ветвления (например, if или тернарный оператор) шаблон
                                                    заменяет его предикат другим выражением, собранным в той же области
                                                    видимости.</td>
                                            </tr>
                                            <tr>
                                                <td>Expression Adder and Remover</td>
                                                <td>Для условного ветвления шаблон добавляет или удаляет терм в
                                                    предикате. При добавлении терма шаблон собирает предикаты в той же
                                                    области видимости.</td>
                                            </tr>
                                            <tr>
                                                <td>Null Pointer Checker</td>
                                                <td>Для оператора программы шаблон добавляет оператор if(), проверяющий,
                                                    не равен ли объект null, если в операторе есть ссылки на объект.
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Object Initializer</td>
                                                <td>Для переменной, участвующей во входе к вызову метода, шаблон
                                                    вставляет оператор инициализации перед вызовом. Инициализатор
                                                    использует базовый конструктор без параметров.</td>
                                            </tr>
                                            <tr>
                                                <td>Range Checker</td>
                                                <td>Для оператора с обращением к массивам шаблон добавляет if(),
                                                    проверяющий, не выходит ли индекс за верхнюю и нижнюю границы
                                                    массива, перед выполнением операторов, обращающихся к массиву.</td>
                                            </tr>
                                            <tr>
                                                <td>Collection Size Checker</td>
                                                <td>Для переменной коллекционного типа шаблон добавляет оператор if(),
                                                    проверяющий, не превышает ли индекс размер коллекции.</td>
                                            </tr>
                                            <tr>
                                                <td>Class Cast Checker</td>
                                                <td>Для оператора приведения типа шаблон вставляет оператор if(),
                                                    проверяющий, что приведение корректно (с помощью instanceof).</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div class="table-caption">Таблица II – Шаблоны исправлений, выведенные из шаблонов
                                        раздела II‑C</div>
                                </div>

                                <p><strong>Parameter Replacer</strong> выведен из шаблона «Изменение параметров метода»
                                    в таблице I. Его сценарий изменяет параметры вызова метода. Кандидаты на подстановку
                                    параметров собираются в той же области видимости, что и вызов, и должны иметь
                                    совместимые типы. Эти кандидаты сортируются по расстоянию (количество узлов) от
                                    места дефекта в AST. PAR выбирает одного из них с учётом этого расстояния и заменяет
                                    параметр в операторе вызова метода.</p>

                                <p><strong>Method Replacer</strong> заменяет имя вызываемого метода в операторах вызова.
                                    Шаблон содержит шаг проверки контекста, который ищет другие вызовы методов с теми же
                                    параметрами и возвращаемым типом в той же области видимости. Если кандидатов
                                    несколько, PAR случайно выбирает один из них для замены имени метода. Шаблон выведен
                                    из «Вызов другого метода с теми же параметрами».</p>
                                <div class="code-block">
                                    <pre>01 if (kidMatch != -1) return kidMatch;
02 for (int i = num; i < state.parenCount; i++)
03 {
04   state.parens[i].length = 0;
05 }
06 state.parenCount = num;</pre>
                                    <div class="code-caption">(a) Ошибочная программа (подчёркнутая строка — место
                                        дефекта)</div>
                                </div>

                                <div class="code-block">
                                    <pre>...
...
+ if ( ) {
    state.parens[i].length = 0;
+ }
...
...
где условие: state != null && state.parens[i] != null</pre>
                                </div>

                                <div class="code-block">
                                    <pre>01 if (kidMatch != -1) return kidMatch;
02 for ( ... )
03 {
04+  if (state != null && state.parens[i] != null)
05       state.parens[i].length = 0;
06 }
07 state.parenCount = num;</pre>
                                    <div class="code-caption">(б) После применения шаблона: патч, сгенерированный PAR.
                                        Как видно, соответствующие операторы были изменены по сценарию шаблона.
                                        <br> Рис. 5. Пример применения шаблона «Null Pointer Checker» к
                                        NativeRegExp.java для исправления ошибки Rhino Bug #76683
                                    </div>
                                </div>
                                <p><strong>Parameter Adder and Remover</strong> позволяет сделать вызов метода с большим
                                    или меньшим числом параметров. Он применим лишь тогда, когда у метода есть
                                    перегруженные версии. PAR случайным образом выбирает одну из доступных перегрузок.
                                    При добавлении параметров шаблон указывает, как сканировать ту же область видимости
                                    в поисках совместимых переменных. При удалении параметры, отсутствующие в выбранной
                                    перегруженной версии, убираются. Этот шаблон выведен из «Вызов другой перегруженной
                                    версии с дополнительным параметром».</p>

                                <p><strong>Expression Replacer</strong> и <strong>Expression Adder and Remover</strong>
                                    основаны на патчах, изменяющих предикаты в условных и циклических операторах (if,
                                    while, тернарный оператор и т.п.), то есть из шаблона «Изменение условия ветвления».
                                    Для замены или добавления предиката PAR сначала сканирует предикаты в той же области
                                    видимости. Они сортируются по расстоянию в AST от места дефекта, и PAR выбирает один
                                    с учётом этого расстояния. При удалении терма из предиката PAR случайным образом
                                    выбирает терм для удаления.</p>

                                <p>Шаблон <strong>Object Initializer</strong> вставляет оператор инициализации в место
                                    дефекта. Конструктор — базовый, без параметров, что предотвращает null у переменной.
                                    Шаблон выведен из «Инициализация объекта».</p>

                                <p>Шаблоны <strong>Null Pointer Checker</strong>, <strong>Range Checker</strong>,
                                    <strong>Collection Size Checker</strong> и <strong>Class Cast Checker</strong>
                                    выведены из соответствующих шаблонов в таблице I. С их помощью PAR может вставить
                                    оператор if(), проверяющий аномальное состояние (null‑ссылка, выход за границы
                                    массива, некорректное приведение типа и др.).
                                </p>
                            </div>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Оценка пригодности</div>
                            <p>Функция пригодности нашего подхода принимает вариант программы и тесты, а затем
                                возвращает значение, представляющее количество пройденных тестов. Эта функция
                                адаптирована из [7], [8]. Все тесты собираются из репозитория кода соответствующей
                                программы, включая провалившиеся тесты, воспроизводящие ошибку. Результирующее значение
                                пригодности используется для оценки и сравнения вариантов в популяции: «какой вариант
                                лучше остальных?». На основе значений пригодности PAR выбирает варианты, используя схему
                                турнирного отбора [18] (строка 4 алгоритма 1).</p>
                        </div>
                    </div>

                    <div class="section">
                        <div class="section-title-center">Оценка</div>
                        <p>В этом разделе мы представляем экспериментальную оценку PAR. В частности, эксперименты
                            спроектированы, чтобы ответить на следующие исследовательские вопросы:</p>
                        <ol>
                            <li>RQ1 (Исправляемость): сколько ошибок удаётся успешно исправить?</li>
                            <li>RQ2 (Приемлемость): какой подход генерирует более приемлемые патчи?</li>
                        </ol>

                        <div class="subsection">
                            <div class="section-title">Экспериментальный дизайн</div>
                            <p>Для оценки PAR мы собрали 119 реальных ошибок из проектов с открытым исходным кодом
                                (таблица III). Для каждой ошибки мы применили как PAR, так и GenProg [8] для генерации
                                патчей. Затем мы проверили, сколько ошибок было успешно исправлено каждым подходом
                                (RQ1). Кроме того, мы провели пользовательское исследование для сравнения качества
                                патчей двух подходов (RQ2).</p>

                            <p>Шесть проектов в таблице III написаны на Java. Мы выбрали их по двум основным причинам.
                                Во‑первых, Java — один из самых популярных языков программирования⁵, поэтому существует
                                множество Java‑проектов. Во‑вторых, благодаря JUnit⁶ и другим фреймворкам тестирования
                                на Java, многие Java‑проекты содержат большое число тестов.</p>

                            <p>Многие проекты с открытым исходным кодом используют собственные системы отслеживания
                                ошибок (Bugzilla, JIRA и т.п.). Для экспериментов мы выбрали шесть таких проектов:
                                Mozilla Rhino, Eclipse AspectJ, Apache Log4j и Apache Commons (Math, Lang, Collections),
                                поскольку они часто используются в литературе [6], [19], [20] и имеют хорошо
                                сопровождаемые отчёты об ошибках. Мы старались находить воспроизводимые ошибки в
                                трекерах, а затем случайно выбирали от 15 до 29 ошибок на проект (так как ошибок было
                                очень много).</p>

                            <p>Хотя мы приложили максимум усилий к сбору ошибок, выборка из 119 ошибок не является
                                исчерпывающим представлением всех возможных ошибок. Тем не менее, насколько нам
                                известно, 119 — это наибольшее число ошибок в оценке методов автоматической генерации
                                исправлений на момент публикации.</p>

                            <p>Для каждой ошибки мы собирали все доступные тесты из соответствующего репозитория,
                                включая провалившиеся тесты, воспроизводящие ошибку. В проектах обычно много тестов,
                                поскольку разработчики постоянно пишут и поддерживают их [21]. В наших экспериментах мы
                                использовали все тесты (см. таблицу III) для проверки кандидатов в патчи [6], [7], [10].
                            </p>

                            <p>При применении PAR и GenProg к каждой ошибке мы выполняли по 100 запусков. Arcuri и
                                Briand рекомендуют минимум 1000 запусков для оценки рандомизированных алгоритмов [22],
                                однако из‑за ограниченного времени мы сделали 100 запусков. Итого эксперимент включал 23
                                800 запусков (100 × 119 ошибок × 2 подхода).</p>

                            <p>Каждый запуск останавливался по достижении 10 поколений или через 8 часов (реальное
                                время). Если к этому моменту исправление не находилось, мы считали, что запуск
                                неуспешен. Мы использовали те же условия остановки, что и в [8], для справедливого
                                сравнения.</p>

                            <p>Кроме того, мы использовали тот же размер популяции (=40), что и в GenProg, а также такие
                                же параметры (например, вероятность мутации), рекомендованные в [8] для GenProg.</p>

                            <p>Эксперименты выполнялись на нескольких машинах с двумя 6‑ядерными 3 ГГц процессорами и 16
                                ГБ RAM. Тесты запускались параллельно для ускорения, а значения пригодности вариантов
                                кэшировались (memoization), чтобы не повторять оценку одного и того же варианта, как
                                описано в [7].</p>

                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Проект</th>
                                            <th># ошибок</th>
                                            <th>LOC</th>
                                            <th># операторов</th>
                                            <th># тестов</th>
                                            <th>Описание</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Rhino</td>
                                            <td>17</td>
                                            <td>51 001</td>
                                            <td>35 161</td>
                                            <td>5 578</td>
                                            <td>интерпретатор</td>
                                        </tr>
                                        <tr>
                                            <td>AspectJ</td>
                                            <td>18</td>
                                            <td>180 394</td>
                                            <td>139 777</td>
                                            <td>1 602</td>
                                            <td>компилятор</td>
                                        </tr>
                                        <tr>
                                            <td>log4j</td>
                                            <td>15</td>
                                            <td>27 855</td>
                                            <td>19 933</td>
                                            <td>705</td>
                                            <td>логгер</td>
                                        </tr>
                                        <tr>
                                            <td>Math</td>
                                            <td>29</td>
                                            <td>121 168</td>
                                            <td>80 764</td>
                                            <td>3 538</td>
                                            <td>мат. утилиты</td>
                                        </tr>
                                        <tr>
                                            <td>Lang</td>
                                            <td>20</td>
                                            <td>54 537</td>
                                            <td>40 436</td>
                                            <td>2 051</td>
                                            <td>утилиты</td>
                                        </tr>
                                        <tr>
                                            <td>Collections</td>
                                            <td>20</td>
                                            <td>48 049</td>
                                            <td>35 335</td>
                                            <td>11 577</td>
                                            <td>утилиты</td>
                                        </tr>
                                        <tr>
                                            <td>Итого</td>
                                            <td>119</td>
                                            <td>483 004</td>
                                            <td>351 406</td>
                                            <td>25 051</td>
                                            <td></td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="table-caption">Таблица III – Набор данных для экспериментов</div>
                            </div>
                        </div>

                        <div class="subsection">
                            <div class="section-title">RQ1: Исправляемость</div>

                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Проект</th>
                                            <th># ошибок</th>
                                            <th># исправленных GenProg</th>
                                            <th># исправленных PAR</th>
                                            <th># исправленных обоими</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Rhino</td>
                                            <td>17</td>
                                            <td>7</td>
                                            <td>6</td>
                                            <td>4</td>
                                        </tr>
                                        <tr>
                                            <td>AspectJ</td>
                                            <td>18</td>
                                            <td>0</td>
                                            <td>9</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td>log4j</td>
                                            <td>15</td>
                                            <td>0</td>
                                            <td>5</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td>Math</td>
                                            <td>29</td>
                                            <td>5</td>
                                            <td>3</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <td>Lang</td>
                                            <td>20</td>
                                            <td>1</td>
                                            <td>0</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td>Collections</td>
                                            <td>20</td>
                                            <td>3</td>
                                            <td>4</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td>Итого</td>
                                            <td>119</td>
                                            <td>16</td>
                                            <td>27</td>
                                            <td>5</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="table-caption">Таблица IV – Результаты генерации патчей</div>
                            </div>

                            <p>PAR успешно исправил 27 из 119 ошибок, тогда как GenProg сгенерировал исправления только
                                для 16 ошибок. Из исправленных ошибок 5 (4 в Rhino и 1 в Math) были исправлены обоими
                                подходами. При этом патчи двух подходов различались, хотя все они проходили тесты. Эти 5
                                ошибок использовались в сравнительном исследовании приемлемости патчей (раздел IV‑C).
                            </p>

                            <p>Использование шаблонов исправлений оказалось эффективным. Например, шаблон Range Checker
                                сгенерировал патч для Rhino bug #114493, вставив оператор if() (см. рис. 1(d)). Ошибка
                                AspectJ bug #131933 была исправлена с помощью шаблона Class Cast Checker, поскольку в
                                ошибочных операторах использовалось некорректное приведение типа. Шаблоны Expression
                                Replacer и Expression Adder and Remover сгенерировали успешные патчи для двух ошибок
                                Rhino (#192226 и #222635), где ошибочными были предикаты в операторах if().</p>

                            <p>Важно отметить, что мы выделяли шаблоны исправлений, анализируя патчи Eclipse JDT, а
                                затем использовали эти шаблоны для генерации патчей в других проектах — Mozilla Rhino,
                                Apache Commons Math и др. Это указывает на повторное использование шаблонов между
                                проектами.</p>

                            <p>Хотя в статье описано всего 10 шаблонов, они уже заметно расширили исправляемость ошибок.
                                Выявление дополнительных шаблонов из существующих патчей может ещё больше улучшить
                                исправляемость — это направление будущей работы.</p>

                            <p>GenProg исправил порядка 10% ошибок в нашей оценке, в то время как в последнем
                                систематическом исследовании [8] сообщалось об исправлении ~50% ошибок в C‑проектах.
                                Возможно, причина в том, что операции мутаций GenProg менее эффективны для
                                Java‑программ. Большинство Java‑программ разбивают функциональность на небольшие классы
                                и методы, что ограничивает множество операторов, доступных для мутаций, так как GenProg
                                оперирует операторами из той же области видимости. С другой стороны, C‑программы часто
                                имеют много глобальных переменных и большие функции, что даёт больше шансов
                                задействовать корректные операторы в мутациях (в [8] авторы GenProg приводят патч,
                                исправляющий обращение к глобальной переменной, как показательный пример успешного
                                случая). Однако это не означает, что наш набор проектов был предвзят против GenProg: PAR
                                имел те же ограничения, что и GenProg, и, кроме того, наш подход не ограничивается
                                только Java.</p>

                            <p><strong>Итог:</strong> PAR сгенерировал исправления для 27 ошибок, тогда как GenProg —
                                для 16.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">RQ2: Приемлемость</div>
                            <p>В этом разделе мы оцениваем приемлемость патчей, сгенерированных PAR и GenProg. Поскольку
                                все успешные патчи по определению проходят имеющиеся тесты, сложно систематически
                                выбирать среди них более и менее «хорошие» патчи. Вместо этого мы анонимизировали патчи
                                и попросили людей‑участников оценить, какие патчи они сочли бы приемлемыми.</p>

                            <p>Чтобы ответить на RQ2, мы сформулировали следующие нулевые гипотезы:</p>
                            <ol>
                                <li>H₁⁰: Патчи, сгенерированные PAR и GenProg, не различаются по приемлемости.</li>
                                <li>H₂⁰: Патчи, сгенерированные PAR, не различаются по приемлемости от патчей,
                                    написанных людьми.</li>
                            </ol>
                            <p>Соответствующие альтернативные гипотезы:</p>
                            <ol>
                                <li>H₁ᵃ: PAR генерирует более приемлемые патчи, чем GenProg.</li>
                                <li>H₂ᵃ: Патчи, сгенерированные PAR, более приемлемы, чем патчи, написанные людьми.</li>
                            </ol>

                            <div class="subsubsection">
                                <div class="section-title">Участники</div>
                                <p>Для исследования мы привлекли две группы: студентов‑информатиков и разработчиков.</p>
                                <ul>
                                    <li><strong>Группа студентов:</strong> 17 аспирантов по программной инженерии,
                                        имеющих от 2 до 5 лет опыта программирования на Java.</li>
                                    <li><strong>Группа разработчиков:</strong> 68 разработчиков, набранных через
                                        онлайн‑сообщества («stackoverflow.com», «coderanch.com») и компании (например,
                                        Daum, крупная интернет‑компания в Корее). Мы приглашали только тех, у кого есть
                                        опыт программирования на Java.</li>
                                </ul>
                            </div>

                            <div class="subsubsection">
                                <div class="section-title">Дизайн исследования</div>
                                <p>Анкетирование состояло из 5 сессий. В каждой сессии рассматривалась одна из пяти
                                    ошибок, исправленных обоими подходами (см. таблицу IV). В каждой сессии подробно
                                    объяснялось, в чём ошибка и почему она проблематична, а также давалась ссылка на
                                    отчёт об ошибке. После этого участникам предъявлялись три анонимных патча:</p>
                                <ol>
                                    <li>патч, написанный человеком;</li>
                                    <li>патч, сгенерированный PAR;</li>
                                    <li>патч, сгенерированный GenProg.</li>
                                </ol>
                                <p>Каждому участнику предлагалось ранжировать эти три патча по приемлемости, как если бы
                                    он выступал в роли ревьюера кода.</p>

                                <p>Мы реализовали веб‑инструмент опроса, который показывал пять сессий в случайном
                                    порядке. Ссылку на опрос получили обе группы участников. В начале мы подчёркивали,
                                    что все показанные патчи проходят все тесты соответствующего проекта. Временных
                                    ограничений не было, чтобы участники могли тщательно изучить патчи.</p>
                            </div>

                            <div class="subsubsection">
                                <div class="section-title">Результаты — студенты</div>

                                <div class="table-container">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Ошибка</th>
                                                <th>Человек (ср.±σ)</th>
                                                <th>PAR (ср.±σ)</th>
                                                <th>GenProg (ср.±σ)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>Math #280</td>
                                                <td>1.33 (0.62)</td>
                                                <td>2.27 (0.59)</td>
                                                <td>2.40 (0.83)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #114493</td>
                                                <td>2.00 (0.54)</td>
                                                <td>1.33 (0.62)</td>
                                                <td>2.67 (0.72)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #192226</td>
                                                <td>1.47 (0.64)</td>
                                                <td>1.67 (0.62)</td>
                                                <td>2.67 (0.72)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #217379</td>
                                                <td>1.69 (0.70)</td>
                                                <td>1.50 (0.63)</td>
                                                <td>2.81 (0.40)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #76683</td>
                                                <td>2.13 (0.51)</td>
                                                <td>1.07 (0.26)</td>
                                                <td>2.80 (0.41)</td>
                                            </tr>
                                            <tr>
                                                <td>Среднее</td>
                                                <td>1.72 (0.67)</td>
                                                <td>1.57 (0.68)</td>
                                                <td>2.67 (0.64)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div class="table-caption">Таблица V – Средние ранги (чем меньше число, тем выше
                                        ранг), 17 студентов</div>
                                </div>

                                <p>Патчи, сгенерированные PAR, во всех пяти ошибках получили лучшие средние ранги, чем
                                    патчи GenProg. В среднем ранг патчей PAR — 1.57 (σ = 0.68), а патчей GenProg — 2.67
                                    (σ = 0.64). Разница статистически значима (p = 0.000 < 0.05). Для проверки мы
                                        использовали критерий Вилкоксона для связанных выборок [23], поскольку
                                        сравниваются две зависимые выборки, и данные не являются параметрическими. На
                                        основании этого мы можем отвергнуть H₁⁰ для группы студентов.</p>

                                        <p>Некоторые студенты ранжировали патчи PAR столь же высоко или даже выше, чем
                                            человеческие. Однако средние различия между патчами PAR (1.57) и
                                            человеческими патчами (1.72, σ = 0.67) статистически не значимы (p = 0.257 >
                                            0.05). Поэтому мы не можем отвергнуть H₂⁰ для студенческой группы.</p>
                            </div>

                            <div class="subsubsection">
                                <div class="section-title">Результаты — разработчики</div>

                                <div class="table-container">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Ошибка</th>
                                                <th>Человек (ср.±σ)</th>
                                                <th>PAR (ср.±σ)</th>
                                                <th>GenProg (ср.±σ)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>Math #280</td>
                                                <td>1.92 (0.76)</td>
                                                <td>2.00 (0.82)</td>
                                                <td>2.08 (0.95)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #114493</td>
                                                <td>1.60 (0.63)</td>
                                                <td>2.40 (0.74)</td>
                                                <td>2.00 (0.93)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #192226</td>
                                                <td>2.00 (0.68)</td>
                                                <td>1.79 (0.98)</td>
                                                <td>2.21 (0.80)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #217379</td>
                                                <td>1.62 (0.77)</td>
                                                <td>1.69 (0.63)</td>
                                                <td>2.69 (0.63)</td>
                                            </tr>
                                            <tr>
                                                <td>Rhino #76683</td>
                                                <td>1.92 (0.64)</td>
                                                <td>1.23 (0.43)</td>
                                                <td>2.85 (0.38)</td>
                                            </tr>
                                            <tr>
                                                <td>Среднее</td>
                                                <td>1.81 (0.70)</td>
                                                <td>1.82 (0.80)</td>
                                                <td>2.36 (0.90)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div class="table-caption">Таблица VI – Средние ранги (чем меньше число, тем выше
                                        ранг), 68 разработчиков</div>
                                </div>

                                <p>Как и в случае студентов, патчи PAR в среднем оценены выше, чем патчи GenProg
                                    (исключение — Rhino Bug #114493, где GenProg иногда воспринимался как более
                                    приемлемый благодаря присвоению «значения по умолчанию» при lhs == undefined, см.
                                    рис. 1(b)).</p>

                                <p>Средний ранг PAR — 1.82 (σ = 0.80), GenProg — 2.36 (σ = 0.90). Различия статистически
                                    значимы (p = 0.016 < 0.05), поэтому мы можем отвергнуть H₁⁰ для группы
                                        разработчиков.</p>

                                        <p>Средний ранг человеческих патчей — 1.81 (σ = 0.70). Различия между патчами
                                            PAR и человеческими патчами статистически не значимы (p = 0.411 > 0.05),
                                            поэтому H₂⁰ не отвергается.</p>

                                        <p>Таким образом, оба исследования (со студентами и разработчиками) показывают,
                                            что патчи PAR в среднем более приемлемы, чем патчи GenProg, и при этом
                                            сопоставимы с человеческими патчами по приемлемости.</p>
                            </div>

                            <div class="subsubsection">
                                <div class="section-title">Непрямая сравнительная оценка патчей</div>
                                <p>Описанные выше исследования основывались на прямом сравнении трёх патчей (человек /
                                    PAR / GenProg), но только для пяти ошибок, исправленных обоими подходами. Чтобы
                                    косвенно сравнить все 43 патча (27 от PAR и 16 от GenProг), мы провели ещё одно
                                    исследование, сравнивая их по отдельности с человеческими патчами.</p>

                                <p>Мы создали веб‑опрос, где в каждой сессии показывалась пара анонимных патчей: один
                                    человеческий и один машинный (от PAR или GenProg) для одной и той же ошибки. Вместе
                                    с ними давалась информация об ошибке. Участников просили выбрать более приемлемый
                                    патч. Дополнительно предоставлялись варианты «оба приемлемы» и «затрудняюсь
                                    ответить». Все 43 сессии показывались в случайном порядке; участники могли ответить
                                    на произвольное количество сессий.</p>

                                <p>Мы пригласили участников через разработческие сообщества, Twitter и по электронной
                                    почте студентов старших курсов (с опытом Java). В приглашениях подчёркивалось, что
                                    участие рекомендуется только тем, кто знаком с Java.</p>

                                <p><strong>Результаты:</strong> всего 168 участников (72 студента и 96 разработчиков)
                                    ответили на 965 сессий. Число ответов по патчам PAR и GenProg (621 и 344) примерно
                                    отражает отношение количества успешных патчей (27:16), что говорит о случайном
                                    распределении сессий.</p>

                                <div class="table-container">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Выбор</th>
                                                <th># ответов</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>PAR</td>
                                                <td>130 (21%)</td>
                                            </tr>
                                            <tr>
                                                <td>Оба приемлемы</td>
                                                <td>175 (28%)</td>
                                            </tr>
                                            <tr>
                                                <td>Человек</td>
                                                <td>229 (37%)</td>
                                            </tr>
                                            <tr>
                                                <td>Затрудняюсь</td>
                                                <td>87 (14%)</td>
                                            </tr>
                                            <tr>
                                                <td>Итого</td>
                                                <td>621 (100%)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div class="table-caption">Таблица VII(a) – Сравнение PAR с человеческими патчами
                                    </div>
                                </div>

                                <p>В 130 случаях (21%) участники предпочли патч PAR, в 175 (28%) — сочли оба патча
                                    приемлемыми. Итого патчи PAR воспринимались как приемлемые в 305 сессиях (49%).</p>

                                <div class="table-container">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Выбор</th>
                                                <th># ответов</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>GenProg</td>
                                                <td>68 (20%)</td>
                                            </tr>
                                            <tr>
                                                <td>Оба приемлемы</td>
                                                <td>40 (12%)</td>
                                            </tr>
                                            <tr>
                                                <td>Человек</td>
                                                <td>176 (51%)</td>
                                            </tr>
                                            <tr>
                                                <td>Затрудняюсь</td>
                                                <td>60 (17%)</td>
                                            </tr>
                                            <tr>
                                                <td>Итого</td>
                                                <td>344 (100%)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div class="table-caption">Таблица VII(b) – Сравнение GenProg с человеческими
                                        патчами</div>
                                </div>

                                <p>Патчи GenProg были сочтены приемлемыми в 108 сессиях (32%: 20% предпочли GenProg, 12%
                                    — «оба приемлемы»).</p>

                                <p>Эти непрямые результаты также показывают, что патчи PAR в среднем более приемлемы,
                                    чем патчи GenProg.</p>

                                <p><strong>Итог:</strong> PAR генерирует более приемлемые патчи, чем GenProg.</p>
                            </div>
                        </div>
                    </div>

                    <div class="section">
                        <div class="section-title">Обсуждение</div>
                        <p>В этом разделе мы рассматриваем неуспешные случаи PAR и обсуждаем угрозы валидности
                            экспериментов.</p>

                        <div class="subsection">
                            <div class="section-title">Неуспешные исправления</div>
                            <p>Согласно таблице IV, 92 из 119 ошибок не были исправлены PAR. Мы проанализировали
                                основные причины неудач и выделили два типа проблем (таблица VIII):</p>
                            <ol>
                                <li>сложные условия ветвления,</li>
                                <li>отсутствие подходящих шаблонов.</li>
                            </ol>

                            <div class="table-container">
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Причина</th>
                                            <th># ошибок</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Условие ветвления</td>
                                            <td>26 (28%)</td>
                                        </tr>
                                        <tr>
                                            <td>Нет подходящего шаблона</td>
                                            <td>66 (72%)</td>
                                        </tr>
                                    </tbody>
                                </table>
                                <div class="table-caption">Таблица VIII – Причины неуспешных исправлений</div>
                            </div>

                            <p><strong>1) Условия ветвления.</strong></p>
                            <p>PAR не может сгенерировать предикаты, удовлетворяющие условиям ветвления в месте дефекта,
                                используя только существующие шаблоны. Из‑за этого не удалось исправить 26 ошибок (28%).
                                Например, в Rhino bug #181834 ошибка возникает, когда переменной scope присваивается
                                объект типа NativeCall или NativeWith. Для исправления требуется вставить оператор
                                ветвления перед местом дефекта с предикатом, проверяющим тип scope. Синтез такого
                                предиката «с нуля» — сложная задача.</p>

                            <p><strong>2) Отсутствие подходящего шаблона.</strong></p>
                            <p>PAR не может сгенерировать успешный патч, если ни один из имеющихся шаблонов не задаёт
                                нужное преобразование. 66 ошибок (72%) были не исправлены именно поэтому. Например, для
                                исправления AspectJ Bug #109614 человеческий патч добавляет оператор:</p>

                            <div class="code-block">
                                <pre>if (sources[i] instanceof ExceptionRange) ...</pre>
                            </div>

                            <p>Однако тип ExceptionRange не очевиден из места дефекта и не выводится автоматическими
                                средствами. Чтобы PAR мог исправить эту ошибку, требуется шаблон, который умеет
                                синтезировать подобные конструкции, то есть более «богатый» шаблон, чем имеющиеся.</p>

                            <p>Мы дополнительно изучили 11 ошибок, исправленных GenProg, но не исправленных PAR. В 7 из
                                11 случаев основная причина та же — нет соответствующего шаблона. Это говорит о том, что
                                добавление новых шаблонов могло бы сделать эти ошибки исправляемыми PAR. Оставшиеся 4
                                ошибки относятся к категории сложных условий ветвления.</p>
                        </div>

                        <div class="subsection">
                            <div class="section-title">Угрозы валидности</div>
                            <p>Мы выделяем следующие угрозы валидности:</p>

                            <p><strong>Только проекты с открытым исходным кодом.</strong></p>
                            <p>Мы оценивали подход на OSS‑проектах, поэтому результаты могут не полностью переноситься
                                на закрытые промышленные проекты. Паттерны исправлений в закрытом ПО могут отличаться.
                            </p>

                            <p><strong>Квалификация участников опросов.</strong></p>
                            <p>В приглашениях на опрос для разработчиков мы указывали, что участие желательно только для
                                профессиональных разработчиков, однако строго проверить их квалификацию мы не могли.</p>
                        </div>
                    </div>

                    <div class="section">
                        <div class="section-title">Связанные работы</div>
                        <p>Weimer и др. [7] предложили GenProg — метод автоматической генерации исправлений на основе
                            генетического программирования. Он случайно мутирует ошибочные программы, чтобы получить
                            множество вариантов, которые служат кандидатами в патчи. Варианты проверяются на успешных и
                            проваленных тестах; если вариант проходит все тесты, он считается успешным патчем. В [8]
                            авторы добавили новую операцию мутации (замену) и убрали операцию switch, а также провели
                            более систематическую оценку на 105 реальных ошибках. Согласно [8], GenProg исправил 55 из
                            105 ошибок. Однако, как показано в разделе IV‑C, GenProg иногда генерирует бессмысленные, с
                            точки зрения разработчика, патчи.</p>

                        <p>Fry и др. провели пользовательское исследование для косвенной оценки качества патчей GenProg
                            с точки зрения поддерживаемости [24]. Участникам показывали патчи и задавали вопросы по
                            поддерживаемости, основанные на работе Sillito, Murphy и Volder [25]. Кроме того, им
                            предоставлялись автоматически сгенерированные документы по изменениям [26]. Авторы
                            обнаружили, что патчи GenProg с сопутствующей документацией сравнимы с человеческими патчами
                            по поддерживаемости. В отличие от этого, мы сравниваем патчи напрямую по приемлемости, не
                            ограничиваясь поддерживаемостью, и сравниваем прудукт двух различных систем (GenProg и PAR).
                        </p>

                        <p>Demsky и др. сосредоточились на предотвращении несогласованностей в структурах данных [27],
                            [28]. Их подход использует формальные спецификации для проверки согласованности структур и
                            вставляет код мониторинга во время выполнения, чтобы избегать неконсистентных состояний.
                            Однако такая техника скорее обеспечивает обходные решения (workarounds), а не настоящие
                            исправления, так как исходный код не модифицируется напрямую.</p>

                        <p>Arcuri и др. предложили метод автоматической генерации исправлений [5]. Хотя они также
                            используют генетическое программирование, их оценка ограничивается небольшими программами
                            (сортировка пузырьком, классификация треугольника и т.п.), тогда как мы оцениваем метод на
                            реальных ошибках в крупных OSS‑проектах. Кроме того, их метод требует наличия формальных
                            спецификаций, тогда как PAR таких спецификаций не требует.</p>

                        <p>Wei и др. предложили основанный на контрактах метод генерации исправлений [10]. Этот метод
                            также опирается на спецификации (контракты) и позволяет генерировать только четыре типа
                            вариантов программ. Эти варианты направлены на проверку нарушений контрактов, тогда как наш
                            подход обобщает реальные патчи людей и может генерировать гораздо более разнообразные
                            варианты.</p>

                        <p>PACHIKA [6] использует модели поведения объектов и была оценена на 26 ошибках в проектах
                            Mozilla и Eclipse. Однако PACHIKA смогла успешно исправить лишь 3 из 26 ошибок, поскольку
                            генерирует только ограниченный набор вариантов (записанное поведение объектов). Наши
                            эксперименты включают те же 26 ошибок (см. таблицу III), и PAR успешно исправил 15 из них
                            (включая все 3, исправленные PACHIKA).</p>

                        <p>Martinez и Monperrus выявили общие действия по ремонту программ (repair actions) на основе
                            ~90 000 исправлений [15]. Они утверждают, что большинство типичных действий — это
                            семантические паттерны, вроде «добавление функциональности». Однако их паттерны достаточно
                            абстрактны и грубые, чтобы быть напрямую использованными при автоматической генерации
                            патчей. В отличие от этого, наши шаблоны (fix templates, раздел III‑B3) достаточно
                            конкретны, чтобы автоматизированно редактировать AST.</p>

                        <p>SYDIT [29] автоматически извлекает сценарий редактирования из одного изменения в программе.
                            Однако пользователь должен вручную указать, какое изменение извлекать и к какой целевой
                            программе его применять. Кроме того, SYDIT не может обобщать несколько изменений в единый
                            сценарий. Улучшенная версия — LASE [30] — может извлекать более общие сценарии из нескольких
                            изменений и автоматически искать целевые места в коде. В будущем PAR может использовать
                            подобные техники для автоматического построения шаблонов исправлений.</p>
                    </div>

                    <div class="section">
                        <div class="section-title">Заключение</div>
                        <p>В этой статье мы предложили новый подход к автоматической генерации исправлений, PAR,
                            основанный на шаблонах исправлений, извлечённых из человеческих патчей, чтобы преодолеть
                            ограничение таких методов, как GenProg [7], [8], а именно — генерацию бессмысленных патчей.
                            Мы сначала вручную проанализировали человеческие патчи и выделили общие шаблоны исправлений;
                            затем использовали их в автоматической генерации патчей.</p>

                        <p>Наши эксперименты на 119 реальных ошибках показали, что PAR успешно сгенерировал исправления
                            для 27 ошибок, в то время как GenProg — только для 16. Чтобы оценить, насколько приемлемы
                            такие исправления, мы провели исследование с 253 участниками (89 студентов и 164
                            разработчика). Результаты показали, что PAR генерирует более приемлемые патчи, чем GenProg,
                            и при этом патчи PAR сопоставимы по приемлемости с патчами, написанными людьми.</p>

                        <p>Наш шаблонно‑ориентированный подход может быть полезен для улучшения других методов
                            автоматической генерации исправлений. Например, техники на основе контрактов [10] в одиночку
                            могут генерировать только несколько типов вариантов; добавление шаблонов исправлений
                            позволяет расширить пространство вариантов. Аналогично, PAR может использоваться для
                            генерации дополнительных вариантов в методах на основе моделей [6].</p>

                        <p>Наши планы на будущее включают:</p>
                        <ol>
                            <li><strong>Автоматический поиск шаблонов исправлений.</strong> Несмотря на успешное
                                применение описанных шаблонов, для повышения исправляемости нужно больше шаблонов. Мы
                                планируем исследовать больше человеческих патчей и разработать алгоритмы для
                                автоматического извлечения шаблонов.</li>
                            <li><strong>Сбалансированная генерация тестов.</strong> Подход PAR требует тестов для оценки
                                вариантов, но часто доступно мало проваливающихся тестов. Несбалансированность (много
                                успешных, мало провальных тестов) может приводить к неточной оценке патчей. Поэтому мы
                                планируем разработать методы генерации дополнительных неуспешных тестов, используя
                                существующие техники автоматического тестирования [31], [32], [20].</li>
                        </ol>

                    </div>

                    <div class="references">
                        <div class="section-title">Литература</div>
                        <div class="reference-list">
                            <div class="reference-item">1. The Guardian, "Why we all sell code with bugs," Aug 2006.
                            </div>
                            <div class="reference-item">2. A. Zeller, Why Programs Fail: A Guide to Systematic
                                Debugging. Morgan Kaufmann, October 2005.</div>
                            <div class="reference-item">3. Technology Review, "So many bugs, so little time," Jul 2010.
                            </div>
                            <div class="reference-item">4. CNN, "Will bugs scare off users of new Windows 2000," Feb
                                2000.</div>
                            <div class="reference-item">5. A. Arcuri and X. Yao, "A novel co-evolutionary approach to
                                automatic software bug fixing," in CEC '08.</div>
                            <div class="reference-item">6. V. Dallmeier, A. Zeller, and B. Meyer, "Generating fixes from
                                object behavior anomalies," in ASE '09.</div>
                            <div class="reference-item">7. W. Weimer, T. Nguyen, C. Le Goues, and S. Forrest,
                                "Automatically finding patches using genetic programming," in ICSE '09.</div>
                            <div class="reference-item">8. C. Le Goues, M. Dewey-Vogt, S. Forrest, and W. Weimer, "A
                                systematic study of automated program repair: Fixing 55 out of 105 bugs for $8 each," in
                                ICSE '12.</div>
                            <div class="reference-item">9. J. R. Koza, Genetic Programming: On the Programming of
                                Computers by Means of Natural Selection, 1st ed. The MIT Press, Dec. 1992.</div>
                            <div class="reference-item">10. Y. Wei, Y. Pei, C. A. Furia, L. S. Silva, S. Buchholz, B.
                                Meyer, and A. Zeller, "Automated fixing of programs with contracts," in ISSTA '10.</div>
                            <div class="reference-item">D. Babich, P. J. Clarke, J. F. Power, and B. M. G. Kibria,
                                “Using a
                                class abstraction technique to predict faults in OO classes: a case study
                                through six releases of the eclipse JDT,” in SAC ’11.</div>
                            <div class="reference-item">B. Dagenais and M. P. Robillard, “Recommending adaptive changes
                                for
                                framework evolution,” in ICSE ’08.</div>
                            <div class="reference-item"> J. Bevan, E. J. Whitehead, Jr., S. Kim, and M. Godfrey,
                                “Facilitating
                                software evolution research with kenyon,” in ESEC/FSE ’05.</div>
                            <div class="reference-item"> Y. Tian, J. Lawall, and D. Lo, “Identifying linux bug fixing
                                patches,” in
                                ICSE ’12.</div>
                            <div class="reference-item">M. Martinez and M. Monperrus, “Mining repair actions for guiding
                                automated program fixing,” INRIA, Tech. Rep., 2012.</div>
                            <div class="reference-item"> T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M. Al-Kofahi, and T.
                                N.
                                Nguyen, “Graph-based mining of multiple object usage patterns,” in
                                ESEC/FSE ’09.</div>
                            <div class="reference-item">Y. Tao, Y. Dang, T. Xie, D. Zhang, and S. Kim, “How do
                                developers
                                understand code changes? an exploratory study in industry,” in FSE ’12.</div>
                            <div class="reference-item">B. L. Miller and D. E. Goldberg, “Genetic algorithms, selection
                                schemes,
                                and the varying effects of noise,” Evol. Comput., vol. 4, no. 2.</div>
                            <div class="reference-item"> A. Nistor, Q. Luo, M. Pradel, T. R. Gross, and D. Marinov,
                                “BALLERINA: automatic generation and clustering of efficient random unit tests
                                for multithreaded code,” in ICSE ’12.</div>
                            <div class="reference-item"> H. Jaygarl, S. Kim, T. Xie, and C. K. Chang, “OCAT: object
                                capturebased automated testing,” in ISSTA ’10.</div>
                            <div class="reference-item">L. S. Pinto, S. Sinha, and A. Orso, “Understanding myths and
                                realities
                                of test-suite evolution,” in FSE ’12.</div>
                            <div class="reference-item">A. Arcuri and L. Briand, “A practical guide for using
                                statistical tests to
                                assess randomized algorithms in software engineering,” in ICSE ’11.</div>
                            <div class="reference-item"> F. Wilcoxon, “Individual comparisons by ranking methods,”
                                Biometrics
                                Bulletin, vol. 1, no. 6.</div>
                            <div class="reference-item"> Z. P. Fry, B. Landau, and W. Weimer, “A human study of patch
                                maintainability,” in ISSTA ’12.</div>
                            <div class="reference-item">J. Sillito, G. C. Murphy, and K. De Volder, “Questions
                                programmers
                                ask during software evolution tasks,” in FSE ’06.</div>
                            <div class="reference-item"> R. P. Buse and W. R. Weimer, “Automatically documenting program
                                changes,” in ASE ’10.</div>
                            <div class="reference-item">B. Demsky and M. Rinard, “Data structure repair using
                                goal-directed
                                reasoning,” in ICSE ’05.</div>
                            <div class="reference-item">B. Demsky, M. D. Ernst, P. J. Guo, S. McCamant, J. H. Perkins,
                                and
                                M. Rinard, “Inference and enforcement of data structure consistency
                                specifications,” in ISSTA ’06.</div>
                            <div class="reference-item"> N. Meng, M. Kim, and K. S. McKinley, “Systematic editing:
                                generating
                                program transformations from an example,” in PLDI ’11.</div>
                            <div class="reference-item">“Lase: Locating and applying systematic edits by learning from
                                examples,” in ICSE ’13.</div>
                            <div class="reference-item"> C. Pacheco, S. K. Lahiri, M. D. Ernst, and T. Ball,
                                “Feedback-Directed
                                random test generation,” in ICSE ’07.</div>
                            <div class="reference-item"> J. H. Andrews, T. Menzies, and F. C. Li, “Genetic algorithms
                                for
                                randomized unit testing,” IEEE Trans. on Softw. Eng., vol. 37, no. 1,
                                pp. 80–94, Feb. 2011.</div>
                        </div>
                    </div>

                    <a href="../../science/index_ru.html" class="article-back-link">← Назад к научным трудам</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Нижнее меню -->
    <footer class="footer-menu">
        <a class="footer-item" href="../../index_ru.html">Резюме</a>
        <a class="footer-item" href="../../diss/index_ru.html">Реферат</a>
        <a class="footer-item" href="../../science/index_ru.html">Научные труды</a>
        <a class="footer-item" href="../../ind/index_ru.html">Индивидуальный раздел</a>
    </footer>

    <script src="../../js/particles-config.js"></script>
    <script src="../../js/main.js"></script>
    <script src="../../js/script.js"></script>

</body>

</html>